{"mappings":"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","sources":["<anon>","node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire0da3\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"6B0gZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"color32BitToUniform\", () => $67025a23fd381e5c$export$2c68e848c5b81f5);\n\"use strict\";\nfunction $67025a23fd381e5c$export$d13a52631f102a23(rgb, alpha, out, offset) {\n    out[offset++] = (rgb >> 16 & 255) / 255;\n    out[offset++] = (rgb >> 8 & 255) / 255;\n    out[offset++] = (rgb & 255) / 255;\n    out[offset++] = alpha;\n}\nfunction $67025a23fd381e5c$export$2c68e848c5b81f5(abgr, out, offset) {\n    const alpha = (abgr >> 24 & 255) / 255;\n    out[offset++] = (abgr & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n    out[offset++] = alpha;\n}\n\n});\n\nparcelRegister(\"6qNFd\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableSprite\", () => $745046e2c487719c$export$fe4bdc7069ee0b9c);\n\"use strict\";\nclass $745046e2c487719c$export$fe4bdc7069ee0b9c {\n    constructor(){\n        // batch specific..\n        this.vertexSize = 4;\n        this.indexSize = 6;\n        this.location = 0;\n        // location in the buffer\n        this.batcher = null;\n        this.batch = null;\n        this.roundPixels = 0;\n    }\n    get blendMode() {\n        return this.renderable.groupBlendMode;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const sprite = this.renderable;\n        const texture = this.texture;\n        const wt = sprite.groupTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const bounds = this.bounds;\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n        const uvs = texture.uvs;\n        const argb = sprite.groupColorAlpha;\n        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n        float32View[index + 0] = a * w1 + c * h1 + tx;\n        float32View[index + 1] = d * h1 + b * w1 + ty;\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        float32View[index + 6] = a * w0 + c * h1 + tx;\n        float32View[index + 7] = d * h1 + b * w0 + ty;\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n        float32View[index + 12] = a * w0 + c * h0 + tx;\n        float32View[index + 13] = d * h0 + b * w0 + ty;\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n        float32View[index + 18] = a * w1 + c * h0 + tx;\n        float32View[index + 19] = d * h0 + b * w1 + ty;\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n    reset() {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n\n});\n\nparcelRegister(\"3JBHn\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShaderGpuProgram\", () => $52144493f15d3fff$export$af9d352c01aa9018);\n$parcel$export(module.exports, \"compileHighShaderGlProgram\", () => $52144493f15d3fff$export$477b8252c7ecdf2);\n\nvar $fK92B = parcelRequire(\"fK92B\");\n\nvar $6j7wq = parcelRequire(\"6j7wq\");\n\nvar $i8pLT = parcelRequire(\"i8pLT\");\n\nvar $jOJh1 = parcelRequire(\"jOJh1\");\n\nvar $8hMvn = parcelRequire(\"8hMvn\");\n\"use strict\";\nfunction $52144493f15d3fff$export$af9d352c01aa9018({ bits: bits, name: name }) {\n    const source = (0, $i8pLT.compileHighShader)({\n        template: {\n            fragment: (0, $jOJh1.fragmentGPUTemplate),\n            vertex: (0, $jOJh1.vertexGPUTemplate)\n        },\n        bits: [\n            (0, $8hMvn.globalUniformsBit),\n            ...bits\n        ]\n    });\n    return (0, $6j7wq.GpuProgram).from({\n        name: name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: \"main\"\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: \"main\"\n        }\n    });\n}\nfunction $52144493f15d3fff$export$477b8252c7ecdf2({ bits: bits, name: name }) {\n    return new (0, $fK92B.GlProgram)({\n        name: name,\n        ...(0, $i8pLT.compileHighShaderGl)({\n            template: {\n                vertex: (0, $jOJh1.vertexGlTemplate),\n                fragment: (0, $jOJh1.fragmentGlTemplate)\n            },\n            bits: [\n                (0, $8hMvn.globalUniformsBitGl),\n                ...bits\n            ]\n        })\n    });\n}\n\n});\nparcelRegister(\"i8pLT\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShader\", () => $9ef573d9dfae5a48$export$86219fd7a1c584d2);\n$parcel$export(module.exports, \"compileHighShaderGl\", () => $9ef573d9dfae5a48$export$ff7039b165d48f97);\n\nvar $9zLXd = parcelRequire(\"9zLXd\");\n\nvar $jJet4 = parcelRequire(\"jJet4\");\n\nvar $ak3Em = parcelRequire(\"ak3Em\");\n\nvar $9hCqF = parcelRequire(\"9hCqF\");\n\nvar $9Zsfg = parcelRequire(\"9Zsfg\");\n\"use strict\";\nconst $9ef573d9dfae5a48$var$cacheMap = /* @__PURE__ */ Object.create(null);\nconst $9ef573d9dfae5a48$var$bitCacheMap = /* @__PURE__ */ new Map();\nlet $9ef573d9dfae5a48$var$CACHE_UID = 0;\nfunction $9ef573d9dfae5a48$export$86219fd7a1c584d2({ template: template, bits: bits }) {\n    const cacheId = $9ef573d9dfae5a48$var$generateCacheId(template, bits);\n    if ($9ef573d9dfae5a48$var$cacheMap[cacheId]) return $9ef573d9dfae5a48$var$cacheMap[cacheId];\n    const { vertex: vertex, fragment: fragment } = $9ef573d9dfae5a48$var$compileInputsAndOutputs(template, bits);\n    $9ef573d9dfae5a48$var$cacheMap[cacheId] = $9ef573d9dfae5a48$var$compileBits(vertex, fragment, bits);\n    return $9ef573d9dfae5a48$var$cacheMap[cacheId];\n}\nfunction $9ef573d9dfae5a48$export$ff7039b165d48f97({ template: template, bits: bits }) {\n    const cacheId = $9ef573d9dfae5a48$var$generateCacheId(template, bits);\n    if ($9ef573d9dfae5a48$var$cacheMap[cacheId]) return $9ef573d9dfae5a48$var$cacheMap[cacheId];\n    $9ef573d9dfae5a48$var$cacheMap[cacheId] = $9ef573d9dfae5a48$var$compileBits(template.vertex, template.fragment, bits);\n    return $9ef573d9dfae5a48$var$cacheMap[cacheId];\n}\nfunction $9ef573d9dfae5a48$var$compileInputsAndOutputs(template, bits) {\n    const vertexFragments = bits.map((shaderBit)=>shaderBit.vertex).filter((v)=>!!v);\n    const fragmentFragments = bits.map((shaderBit)=>shaderBit.fragment).filter((v)=>!!v);\n    let compiledVertex = (0, $ak3Em.compileInputs)(vertexFragments, template.vertex, true);\n    compiledVertex = (0, $9hCqF.compileOutputs)(vertexFragments, compiledVertex);\n    const compiledFragment = (0, $ak3Em.compileInputs)(fragmentFragments, template.fragment, true);\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment\n    };\n}\nfunction $9ef573d9dfae5a48$var$generateCacheId(template, bits) {\n    return bits.map((highFragment)=>{\n        if (!$9ef573d9dfae5a48$var$bitCacheMap.has(highFragment)) $9ef573d9dfae5a48$var$bitCacheMap.set(highFragment, $9ef573d9dfae5a48$var$CACHE_UID++);\n        return $9ef573d9dfae5a48$var$bitCacheMap.get(highFragment);\n    }).sort((a, b)=>a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction $9ef573d9dfae5a48$var$compileBits(vertex, fragment, bits) {\n    const vertexParts = (0, $jJet4.compileHooks)(vertex);\n    const fragmentParts = (0, $jJet4.compileHooks)(fragment);\n    bits.forEach((shaderBit)=>{\n        (0, $9zLXd.addBits)(shaderBit.vertex, vertexParts, shaderBit.name);\n        (0, $9zLXd.addBits)(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n    return {\n        vertex: (0, $9Zsfg.injectBits)(vertex, vertexParts),\n        fragment: (0, $9Zsfg.injectBits)(fragment, fragmentParts)\n    };\n}\n\n});\nparcelRegister(\"9zLXd\", function(module, exports) {\n\n$parcel$export(module.exports, \"addBits\", () => $c36d60e017699465$export$38c21fb192fe3d9);\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\"use strict\";\nfunction $c36d60e017699465$export$38c21fb192fe3d9(srcParts, parts, name) {\n    if (srcParts) for(const i in srcParts){\n        const id = i.toLocaleLowerCase();\n        const part = parts[id];\n        if (part) {\n            let sanitisedPart = srcParts[i];\n            if (i === \"header\") sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n            if (name) part.push(`//----${name}----//`);\n            part.push(sanitisedPart);\n        } else (0, $hUCK4.warn)(`${i} placement hook does not exist in shader`);\n    }\n}\n\n});\n\nparcelRegister(\"jJet4\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHooks\", () => $e10d3f89fc808d5a$export$17705ba43ca63936);\n\"use strict\";\nconst $e10d3f89fc808d5a$export$a564a4c9984eee7d = /\\{\\{(.*?)\\}\\}/g;\nfunction $e10d3f89fc808d5a$export$17705ba43ca63936(programSrc) {\n    const parts = {};\n    const partMatches = programSrc.match($e10d3f89fc808d5a$export$a564a4c9984eee7d)?.map((hook)=>hook.replace(/[{()}]/g, \"\")) ?? [];\n    partMatches.forEach((hook)=>{\n        parts[hook] = [];\n    });\n    return parts;\n}\n\n});\n\nparcelRegister(\"ak3Em\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileInputs\", () => $76be63c34b98a2b0$export$aa47df9391ef0455);\n\"use strict\";\nfunction $76be63c34b98a2b0$var$extractInputs(fragmentSource, out) {\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $76be63c34b98a2b0$export$aa47df9391ef0455(fragments, template, sort = false) {\n    const results = [];\n    $76be63c34b98a2b0$var$extractInputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $76be63c34b98a2b0$var$extractInputs(fragment.header, results);\n    });\n    const mainInput = results;\n    if (sort) mainInput.sort();\n    const finalString = mainInput.map((inValue, i)=>`       @location(${i}) ${inValue},`).join(\"\\n\");\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n    cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n    return cleanedString;\n}\n\n});\n\nparcelRegister(\"9hCqF\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileOutputs\", () => $eeb3f3dfbb29bd14$export$ae19cc473c7ab18);\n\"use strict\";\nfunction $eeb3f3dfbb29bd14$var$extractOutputs(fragmentSource, out) {\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $eeb3f3dfbb29bd14$var$extractVariableName(value) {\n    const regex = /\\b(\\w+)\\s*:/g;\n    const match = regex.exec(value);\n    return match ? match[1] : \"\";\n}\nfunction $eeb3f3dfbb29bd14$var$stripVariable(value) {\n    const regex = /@.*?\\s+/g;\n    return value.replace(regex, \"\");\n}\nfunction $eeb3f3dfbb29bd14$export$ae19cc473c7ab18(fragments, template) {\n    const results = [];\n    $eeb3f3dfbb29bd14$var$extractOutputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $eeb3f3dfbb29bd14$var$extractOutputs(fragment.header, results);\n    });\n    let index = 0;\n    const mainStruct = results.sort().map((inValue)=>{\n        if (inValue.indexOf(\"builtin\") > -1) return inValue;\n        return `@location(${index++}) ${inValue}`;\n    }).join(\",\\n\");\n    const mainStart = results.sort().map((inValue)=>`       var ${$eeb3f3dfbb29bd14$var$stripVariable(inValue)};`).join(\"\\n\");\n    const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue)=>` ${$eeb3f3dfbb29bd14$var$extractVariableName(inValue)}`).join(\",\\n\")});`;\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n    compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n    compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n    compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n    return compiledCode;\n}\n\n});\n\nparcelRegister(\"9Zsfg\", function(module, exports) {\n\n$parcel$export(module.exports, \"injectBits\", () => $650fee7fffdacf4b$export$83c47c7340456c75);\n\"use strict\";\nfunction $650fee7fffdacf4b$export$83c47c7340456c75(templateSrc, fragmentParts) {\n    let out = templateSrc;\n    for(const i in fragmentParts){\n        const parts = fragmentParts[i];\n        const toInject = parts.join(\"\\n\");\n        if (toInject.length) out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n        else out = out.replace(`{{${i}}}`, \"\");\n    }\n    return out;\n}\n\n});\n\n\nparcelRegister(\"jOJh1\", function(module, exports) {\n\n$parcel$export(module.exports, \"vertexGPUTemplate\", () => $f723d8c01fbb4e07$export$61ecfa8d2718163a);\n$parcel$export(module.exports, \"fragmentGPUTemplate\", () => $f723d8c01fbb4e07$export$922d1073ee2ef930);\n$parcel$export(module.exports, \"vertexGlTemplate\", () => $f723d8c01fbb4e07$export$99b0f79e15be8ede);\n$parcel$export(module.exports, \"fragmentGlTemplate\", () => $f723d8c01fbb4e07$export$3f7784dd6a13ff5a);\n\"use strict\";\nconst $f723d8c01fbb4e07$export$61ecfa8d2718163a = /* wgsl */ `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\nconst $f723d8c01fbb4e07$export$922d1073ee2ef930 = /* wgsl */ `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\nconst $f723d8c01fbb4e07$export$99b0f79e15be8ede = /* glsl */ `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\nconst $f723d8c01fbb4e07$export$3f7784dd6a13ff5a = /* glsl */ `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\n});\n\nparcelRegister(\"8hMvn\", function(module, exports) {\n\n$parcel$export(module.exports, \"globalUniformsBit\", () => $d20cb1ce683ff173$export$435d64b3a14c5a51);\n$parcel$export(module.exports, \"globalUniformsBitGl\", () => $d20cb1ce683ff173$export$38608853d4735d51);\n\"use strict\";\nconst $d20cb1ce683ff173$export$435d64b3a14c5a51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* wgsl */ `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\nconst $d20cb1ce683ff173$export$320b7a2ae65b2f3a = {\n    name: \"global-uniforms-ubo-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\nconst $d20cb1ce683ff173$export$38608853d4735d51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n};\n\n});\n\n\nparcelRegister(\"cNnNT\", function(module, exports) {\n\n$parcel$export(module.exports, \"colorBit\", () => $39898bd73b5669c2$export$a62becfe5fe4ad2);\n$parcel$export(module.exports, \"colorBitGl\", () => $39898bd73b5669c2$export$93189e9821cf4459);\n\"use strict\";\nconst $39898bd73b5669c2$export$a62becfe5fe4ad2 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */ `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\nconst $39898bd73b5669c2$export$93189e9821cf4459 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* glsl */ `\n            in vec4 aColor;\n        `,\n        main: /* glsl */ `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\n});\n\nparcelRegister(\"ikSZA\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextureBatchBit\", () => $da5fa72bb41a0724$export$aff2d36945cda647);\n$parcel$export(module.exports, \"generateTextureBatchBitGl\", () => $da5fa72bb41a0724$export$204e46d9a7a4f835);\n\"use strict\";\nconst $da5fa72bb41a0724$var$textureBatchBitGpuCache = {};\nfunction $da5fa72bb41a0724$var$generateBindingSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) {\n        src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n        src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n    } else {\n        let bindingIndex = 0;\n        for(let i = 0; i < maxTextures; i++){\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n    return src.join(\"\\n\");\n}\nfunction $da5fa72bb41a0724$var$generateSampleSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n    else {\n        src.push(\"switch vTextureId {\");\n        for(let i = 0; i < maxTextures; i++){\n            if (i === maxTextures - 1) src.push(`  default:{`);\n            else src.push(`  case ${i}:{`);\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n        src.push(`}`);\n    }\n    return src.join(\"\\n\");\n}\nfunction $da5fa72bb41a0724$export$aff2d36945cda647(maxTextures) {\n    if (!$da5fa72bb41a0724$var$textureBatchBitGpuCache[maxTextures]) $da5fa72bb41a0724$var$textureBatchBitGpuCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${$da5fa72bb41a0724$var$generateBindingSrc(16)}\n            `,\n            main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${$da5fa72bb41a0724$var$generateSampleSrc(16)}\n            `\n        }\n    };\n    return $da5fa72bb41a0724$var$textureBatchBitGpuCache[maxTextures];\n}\nconst $da5fa72bb41a0724$var$textureBatchBitGlCache = {};\nfunction $da5fa72bb41a0724$var$generateSampleGlSrc(maxTextures) {\n    const src = [];\n    for(let i = 0; i < maxTextures; i++){\n        if (i > 0) src.push(\"else\");\n        if (i < maxTextures - 1) src.push(`if(vTextureId < ${i}.5)`);\n        src.push(\"{\");\n        src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push(\"}\");\n    }\n    return src.join(\"\\n\");\n}\nfunction $da5fa72bb41a0724$export$204e46d9a7a4f835(maxTextures) {\n    if (!$da5fa72bb41a0724$var$textureBatchBitGlCache[maxTextures]) $da5fa72bb41a0724$var$textureBatchBitGlCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n            main: `\n    \n                ${$da5fa72bb41a0724$var$generateSampleGlSrc(16)}\n            `\n        }\n    };\n    return $da5fa72bb41a0724$var$textureBatchBitGlCache[maxTextures];\n}\n\n});\n\nparcelRegister(\"kSpdC\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundPixelsBit\", () => $2b55e281ef9e6651$export$22150169726f7b1);\n$parcel$export(module.exports, \"roundPixelsBitGl\", () => $2b55e281ef9e6651$export$222909710f39cc5);\n\"use strict\";\nconst $2b55e281ef9e6651$export$22150169726f7b1 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\nconst $2b55e281ef9e6651$export$222909710f39cc5 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* glsl */ `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n});\n\nparcelRegister(\"huPGn\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformBit\", () => $0f993a3eb7a96f7d$export$1723ac05bd5e9336);\n$parcel$export(module.exports, \"localUniformBitGroup2\", () => $0f993a3eb7a96f7d$export$adb0f80794f644d9);\n$parcel$export(module.exports, \"localUniformBitGl\", () => $0f993a3eb7a96f7d$export$36099520d0a716a);\n\"use strict\";\nconst $0f993a3eb7a96f7d$export$1723ac05bd5e9336 = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* wgsl */ `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    }\n};\nconst $0f993a3eb7a96f7d$export$adb0f80794f644d9 = {\n    ...$0f993a3eb7a96f7d$export$1723ac05bd5e9336,\n    vertex: {\n        ...$0f993a3eb7a96f7d$export$1723ac05bd5e9336.vertex,\n        // replace the group!\n        header: $0f993a3eb7a96f7d$export$1723ac05bd5e9336.vertex.header.replace(\"group(1)\", \"group(2)\")\n    }\n};\nconst $0f993a3eb7a96f7d$export$36099520d0a716a = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* glsl */ `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    }\n};\n\n});\n\n\n//# sourceMappingURL=browserAll.ef84d78a.js.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$67025a23fd381e5c$export$2c68e848c5b81f5","abgr","out","offset","alpha","$745046e2c487719c$export$fe4bdc7069ee0b9c","constructor","vertexSize","indexSize","location","batcher","batch","roundPixels","blendMode","renderable","groupBlendMode","packAttributes","float32View","uint32View","index","textureId","sprite","texture","wt","groupTransform","a","b","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset","$52144493f15d3fff$export$af9d352c01aa9018","$52144493f15d3fff$export$477b8252c7ecdf2","$fK92B","$6j7wq","$i8pLT","$jOJh1","$8hMvn","bits","name","source","compileHighShader","template","fragment","fragmentGPUTemplate","vertex","vertexGPUTemplate","globalUniformsBit","GpuProgram","from","entryPoint","GlProgram","compileHighShaderGl","vertexGlTemplate","fragmentGlTemplate","globalUniformsBitGl","$9ef573d9dfae5a48$export$86219fd7a1c584d2","$9ef573d9dfae5a48$export$ff7039b165d48f97","$9zLXd","$jJet4","$ak3Em","$9hCqF","$9Zsfg","$9ef573d9dfae5a48$var$cacheMap","create","$9ef573d9dfae5a48$var$bitCacheMap","Map","$9ef573d9dfae5a48$var$CACHE_UID","cacheId","$9ef573d9dfae5a48$var$generateCacheId","$9ef573d9dfae5a48$var$compileInputsAndOutputs","vertexFragments","map","shaderBit","filter","fragmentFragments","compiledVertex","compileInputs","compileOutputs","$9ef573d9dfae5a48$var$compileBits","highFragment","has","sort","join","vertexParts","compileHooks","fragmentParts","forEach","addBits","injectBits","$c36d60e017699465$export$38c21fb192fe3d9","$hUCK4","srcParts","parts","i","part","toLocaleLowerCase","sanitisedPart","replace","push","warn","$e10d3f89fc808d5a$export$17705ba43ca63936","$e10d3f89fc808d5a$export$a564a4c9984eee7d","programSrc","partMatches","match","hook","$76be63c34b98a2b0$var$extractInputs","fragmentSource","regex","exec","$76be63c34b98a2b0$export$aa47df9391ef0455","fragments","results","header","mainInput","finalString","inValue","cleanedString","$eeb3f3dfbb29bd14$var$extractOutputs","$eeb3f3dfbb29bd14$export$ae19cc473c7ab18","mainStruct","indexOf","mainStart","value","mainEnd","$eeb3f3dfbb29bd14$var$extractVariableName","compiledCode","$650fee7fffdacf4b$export$83c47c7340456c75","templateSrc","toInject","length","$f723d8c01fbb4e07$export$61ecfa8d2718163a","$f723d8c01fbb4e07$export$922d1073ee2ef930","$f723d8c01fbb4e07$export$99b0f79e15be8ede","$f723d8c01fbb4e07$export$3f7784dd6a13ff5a","$d20cb1ce683ff173$export$435d64b3a14c5a51","$d20cb1ce683ff173$export$38608853d4735d51","$39898bd73b5669c2$export$a62becfe5fe4ad2","$39898bd73b5669c2$export$93189e9821cf4459","main","$da5fa72bb41a0724$export$aff2d36945cda647","$da5fa72bb41a0724$export$204e46d9a7a4f835","$da5fa72bb41a0724$var$textureBatchBitGpuCache","maxTextures","end","$da5fa72bb41a0724$var$generateBindingSrc","src","bindingIndex","$da5fa72bb41a0724$var$generateSampleSrc","$da5fa72bb41a0724$var$textureBatchBitGlCache","$da5fa72bb41a0724$var$generateSampleGlSrc","$2b55e281ef9e6651$export$22150169726f7b1","$2b55e281ef9e6651$export$222909710f39cc5","$0f993a3eb7a96f7d$export$1723ac05bd5e9336","$0f993a3eb7a96f7d$export$adb0f80794f644d9","$0f993a3eb7a96f7d$export$36099520d0a716a"],"version":3,"file":"browserAll.ef84d78a.js.map"}