<html><head>
<link rel="shortcut icon" href="sepeli2.ico" />
<link rel="stylesheet" href="test2.css">
<div class="dropdown">
  <button class="dropbtn">Blender</button>
  <div class="dropdown-content">
    <a href="blender1.html">Blender alkeet</a>
    <a href="blender2.html">Blender animointi</a>
    <a href="blender3.html">Blender sculptaus</a>
    <a href="blender4.html">Blender game, drift</a>
  </div>
</div>
<div class="dropdown">
  <button class="dropbtn">Construct 3</button>
  <div class="dropdown-content">
    <a href="construct1.html">Construct 3: luo ensimm√§inen pelisi!</a>
  </div>
</div>
<div class="dropdown">
  <button class="dropbtn">Unity</button>
  <div class="dropdown-content">
    <a href="unity1.html">1 person tasohyppely</a>
    <a href="unity2.html">2D infinite runner</a>
  </div>
</div>
<div class="dropdown">
  <button class="dropbtn">C#</button>
  <div class="dropdown-content">
    <a href="c.html">C#</a>
  </div>
</div>
<div class="dropdown">
  <button class="dropbtn">Sepeli</button>
  <div class="dropdown-content">
    <a href="sepeli.html">Tietoja</a>
  </div>
</div>
<script src="tes2.js" type="text/javascript" onload = "alku()">></script>
<meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=MXVwpSGzOOhqOc5hUWJbBLizfYjsfH9XaeDpmRKYJN5bV0WvE1cEyAoIq5yYZlSc');ol{margin:0;padding:0}table td,table th{padding:0}.c13{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:538.6pt;border-top-color:#000000;border-bottom-style:solid}.c6{background-color:#ea9999;color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Roboto Mono";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Roboto Mono";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c9{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c21{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c16{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c26{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;text-align:center}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c15{border-spacing:0;border-collapse:collapse;margin-right:auto}.c19{color:#1155cc;text-decoration:underline}.c22{font-weight:400;font-family:"Roboto Mono"}.c25{padding:0pt 28.3pt 0pt 28.3pt}.c18{color:inherit;text-decoration:inherit}.c10{height:11pt}.c14{background-color:#ea9999}.c7{font-weight:700}.c5{margin-left:72pt}.c2{height:0pt}.c11{margin-left:36pt}.c8{margin-left:108pt}.c23{text-indent:36pt}.c17{background-color:#ffffff}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c17 c25"><p class="c26 title" id="h.lumw8ppdh2fe"><span class="c24">Unity Ohjeita</span></p><p class="c1"><span class="c9 c7">Unity</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Unity on suosituin ilmainen pelimoottori jolla voi tehd&auml; pelej&auml;. Se antaa pelikehitt&auml;j&auml;lle vapaat k&auml;det l&auml;hte&auml; luomaan mink&auml;laista peli&auml; tahansa kaikille pelialustoille tietokoneista pelikonsoleille ja k&auml;nnyk&ouml;ille, ja jopa vr-laitteille. Unity saattaa olla haastavaa aluksi, mutta kaikki Unityss&auml; k&auml;ytett&auml;v&auml;t asiat ovat netist&auml; helposti l&ouml;ydett&auml;viss&auml; mik&auml; auttaa aloittelijoita alkuun.</span></p><p class="c1 c10"><span class="c3"></span></p><h1 class="c21" id="h.faf6bkjhoox7"><span class="c12">Unityn k&auml;ynnistys</span></h1><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Kun unityn k&auml;ynnist&auml;&auml; ensimm&auml;isen kerran, kysyy se k&auml;ytt&auml;j&auml;lt&auml; koodia mik&auml;li h&auml;nell&auml; on sellainen. Koska k&auml;yt&auml;mme unityn ilmaisversiota, meill&auml; ei kyseist&auml; koodia ole, joten painamme sen viereisest&auml; ruksista saadaksemme k&auml;ytt&auml;&auml; ilmaista versiota. T&auml;m&auml;n j&auml;lkeen Unity pyyt&auml;&auml; meit&auml; kirjautumaan sis&auml;&auml;n Unity-tunnuksillamme. Ellette ole aijemmin unitya k&auml;ytt&auml;neet, niin teill&auml; ei t&auml;t&auml; viel&auml; ole. Painakaa sinisest&auml; &quot;create one&quot; kohdasta niinkuin kuvassa, niin teid&auml;t vied&auml;&auml;n unityn nettisivuille jossa voitte luoda tunnukset. T&auml;ss&auml; ei pit&auml;isi kovin kauaa menn&auml;.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 713.70px; height: 393.60px;"><img alt="" src="unity1/images/image9.png" style="width: 713.70px; height: 393.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span class="c7 c9">Luo projekti</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Kun p&auml;&auml;semme edellisest&auml; osasta pois, p&auml;&auml;semme unityn perus k&auml;ynnistys n&auml;kym&auml;&auml;n. T&auml;ss&auml; n&auml;kyy kaikki viimeaikaiset projektit jota olet muokannut. Teill&auml; t&auml;m&auml;n pit&auml;isi olla t&auml;ysin tyhj&auml;. Jotta saamme luotua uuden projektin, painetaan &quot;new&quot; oikeasta yl&auml;kulmasta. T&auml;m&auml;n pit&auml;isi avata teille t&auml;m&auml;n n&auml;k&ouml;isen ikkunan. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 328.00px;"><img alt="" src="unity1/images/image17.png" style="width: 601.70px; height: 328.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">T&auml;ss&auml; voimme luoda projektimme. Ensin valitsemme projektillemme nimen. Kannattaa olla tekem&auml;tt&auml; nimest&auml; liian monimutkaista, ja v&auml;ltt&auml;&auml; &auml;&auml;kk&ouml;sien k&auml;ytt&auml;mist&auml;. Seuraavassa kohdassa valitsemme kansion johon projekti luodaan. T&auml;h&auml;n kannattaa luoda oma projektikansionsa jonnekkin tietokoneelle johon tallennat kaikki tulevat projektimme. Seuraavana on organization. Siihen voitte vain valita nimen jonka asetitte itsellenne unityn sivuilla. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Oikealla n&auml;kyy ruksittuna 3D ja ilman ruksia 2D. T&auml;m&auml; tarkoittaa teemmek&ouml; 3D vai 2D projektia, ja luo perusn&auml;kym&auml;n sen mukaan. Koska teemme 3D pelin niin meid&auml;n ei tarvitse muuttaa mit&auml;&auml;n. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Add Asset Package tarkoittaa haluatko lis&auml;t&auml; erillisi&auml; assetteja peliin. Assetit ovat unitylle luotuja kirjastoja joita kuka tahansa voi tehd&auml; ja k&auml;ytt&auml;&auml;. N&auml;it&auml; kirjastoja myyd&auml;&auml;n ja ladataan unity assets storessa. Emme kuitenkaan tarvitse n&auml;it&auml; harjoitusksien aikana, joten meid&auml;n ei tarvitse painaa siit&auml;. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>N&auml;iden alla on viel&auml; Enable unity analytics, joka on unityn tarjoama palvelu, jolla pelin kehitt&auml;j&auml; voi seurata millaisia valintoja pelaaja peliss&auml; tekee. Emme kuitenkaan t&auml;t&auml;k&auml;&auml;n tarvitse, joten sen voi ottaa pois, jolloin my&ouml;s organization kohta menee pois, sill&auml; sit&auml; tarvitaan vain unity analyticsissa. Jos haluatte tiet&auml;&auml; analyticsista enemm&auml;n, lukekaa ominaisuuksista </span><span class="c19"><a class="c18" href="https://www.google.com/url?q=https://unity3d.com/services/analytics&amp;sa=D&amp;ust=1503671713045000&amp;usg=AFQjCNG8J4QGk8hkk62VmV8FZCsHuk5X-Q">t&auml;&auml;lt&auml;</a></span><span class="c3">.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">T&auml;m&auml;n j&auml;lkeen voimme painaa create project ja odottakaa kun unity luo projektin perusn&auml;kym&auml;&auml;. My&ouml;hemmin tehdess&auml;mme projekteja, ohjeissa ei mainita kaikkea n&auml;in tarkkaan.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kun unity on luonut projektin, menee se projektin perusn&auml;kym&auml;&auml;n.</span></p><p class="c1 c10"><span class="c3"></span></p><h2 class="c16" id="h.qvlnq0ob4n2m"><span class="c20">N&auml;kym&auml;t</span></h2><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 629.04px; height: 336.50px;"><img alt="" src="unity1/images/image8.png" style="width: 629.04px; height: 336.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">K&auml;yd&auml;&auml;n hieman l&auml;pi mit&auml; kuvassa n&auml;emme. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Scene</span></p><p class="c1"><span class="c3">Katsomaan ensimm&auml;isen&auml; Scene-n&auml;kym&auml;&auml;, joka on keskell&auml; ruutua. T&auml;ss&auml; voit muokata kaikkea mit&auml; peliin on laitettu. Voit liikkua n&auml;kym&auml;ss&auml; vapaasti. Hiiren keskimm&auml;ist&auml; n&auml;pp&auml;int&auml; pit&auml;m&auml;ll&auml; pohjassa n&auml;kym&auml;ss&auml; ja siirt&auml;m&auml;ll&auml; hiirt&auml; voit liikkua sivuille sek&auml; yl&ouml;s ja alas. Hiiren rullalla saat menty&auml; sceness&auml; eteen ja taakse. Hiiren vasenta n&auml;pp&auml;int&auml; pit&auml;m&auml;ll&auml; pohjassa ja liikuttamalla hiirt&auml; n&auml;et ymp&auml;rillesi. Scene-n&auml;kym&auml;n oikeassa yl&auml;kulmassa on v&auml;rikk&auml;it&auml; lieri&ouml;it&auml;, ja n&auml;it&auml; painamalla saat helposti siirrytty&auml; katsomaan suoraa eli suuntiin. N&auml;kym&auml;n yl&auml;reunassa on my&ouml;s erilaisia nappeja, joissa pit&auml;isi lukea shaded ja 2D, yms. N&auml;it&auml; painamalla voit muuttaa hieman mit&auml; kaikkea sceness&auml; n&auml;kyy ja miten, mutta me emme halua muuttaa n&auml;ist&auml; nyt mit&auml;&auml;n. N&auml;in voit liikkua ja tutkia peli&auml;. Nyt peliss&auml; ei ole viel&auml; mit&auml;&auml;n tutkittavaa koska se on suhteellisen tyhj&auml;, mutta voit huomata kaksi ikonia sceness&auml;, kameran ja valon. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Hierarchy</span></p><p class="c1"><span>Kamera ja valo</span><span class="c3">&nbsp;l&ouml;ytyv&auml;t oletuksena joka scenest&auml; kun se luodaan. Kun katsot vasemmalle Hierarchy-n&auml;kym&auml;&auml;n, n&auml;et t&auml;&auml;ll&auml; kaikki objektit mit&auml; sceness&auml; on, ja siell&auml; pit&auml;isikin olla Main Camera sek&auml; Directional Light. Kun lis&auml;&auml;mme peliin objekteja, ne on kaikki helposti l&ouml;ydett&auml;viss&auml; t&auml;&auml;lt&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Inspector</span></p><p class="c1"><span>Oikealla on n&auml;kyviss&auml; Inspector, joka on t&auml;ll&auml; hetkell&auml; tyhjill&auml;&auml;n, mutta johon ilmestyy asioita, kun napsautamme jotain objektia sceness&auml; tai hierarchy-n&auml;kym&auml;ss&auml;. Inspector-n&auml;kym&auml;ss&auml; n&auml;emme kaikki ominaisuudet mit&auml; valitsemassamme objektissa on. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 582.00px;"><img alt="" src="unity1/images/image1.png" style="width: 432.00px; height: 582.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Ylimp&auml;n&auml; n&auml;kyy objektin nimi, ja sen vasemmalla puolella ruksi onko objekti aktiivinen. Jos napsautamme t&auml;st&auml;, saamme objektin ep&auml;aktiiviseksi, eli peli k&auml;ytt&auml;ytyy niinkuin kyseist&auml; objektia ei olisi olemassa, mutta se silti n&auml;kyy hierarchyssa, ja saamme sen takaisin aktiiviseksi napsauttamalla ruksin p&auml;&auml;lle. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">N&auml;iden alapuolella on objectin tag, eli perjaatteessa ryhm&auml; johon se kuuluu, sek&auml; layer, eli taso jolla objekti on. Kun luomme uuden objectin, oletuksena sen ryhm&auml; on &quot;Untagged&quot;, eli se ei perjaatteessa ole miss&auml;&auml;n ryhm&auml;ss&auml;. Poikkeuksena t&auml;lle on projektiin automaattisesti luotu kamera, jonka tag on MainCamera. Opetamme tagien k&auml;yt&ouml;n hieman my&ouml;hemmin ohjeissa. Jos haluamme ett&auml; jokin objekti on olemassa ja vaikuttaa peliin, muttemme halua ett&auml; pelaaja n&auml;kee t&auml;t&auml;, vaihdamme sen eri layerille, eli tasolle.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">N&auml;iden alapuolella on lista objektin komponenteista, eli kaikista ominaisuuksista joita objektilla on. Jokaisella objektilla on ylimp&auml;n&auml; ominaisuutena transform, sill&auml; mik&auml;&auml;n objekti ei voi toimia ilman t&auml;t&auml;. Transformissa muutamme objektin positionia eli paikkaa, rotatiota eli mihin p&auml;in se on k&auml;&auml;ntyneen&auml;, sek&auml; scale eli skaalausta, eli kuinka suuri objekti on. Voimme muuttaa jokaista yksitt&auml;ist&auml; arvoa miten haluamme nappaamalla arvon vieress&auml; olevasta kirjaimesta eli joko x, y, tai z. Voimme my&ouml;s vain painaa arvosta ja laittaa siihen haluamamme luvun. Kaikki muut objektin komponentit ovat kaikilla eri, joten k&auml;ymme ne l&auml;pi silloin kun se on ajankohtaista.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Project</span></p><p class="c1"><span class="c3">N&auml;yt&ouml;n alhaalla pit&auml;isi olla auki projekti n&auml;kym&auml;, jossa vain lukee ett&auml; &quot;this folder is empty&quot;, eli t&auml;m&auml; kansio on tyhj&auml;. T&auml;&auml;ll&auml; n&auml;kyy kaikki tiedostot mit&auml; peliss&auml; k&auml;yt&auml;mme, kuten kaikki lis&auml;&auml;m&auml;mme 3D-mallit, scriptit eli kooditiedostomme yms. Koska meill&auml; ei viel&auml; projektissa mit&auml;&auml;n ole, niin on t&auml;m&auml; tyhj&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Unityn n&auml;kym&auml; on siis jaettu 4 eri n&auml;ytt&ouml;&ouml;n, joissa on t&auml;ll&auml; hetkell&auml; n&auml;kyviss&auml; Hierarchy, Scene, Inspector ja Project. N&auml;ille n&auml;kymille voidaan kuitenkin asettaa useampiakin ikkunoita, kuten esimerkiksi nettiselaimessa on monta eri ikkunaa, niin samoin n&auml;ill&auml; unityn n&auml;yt&ouml;ill&auml; on ns. monta eri ikkunaa, ja n&auml;m&auml; ikkunat n&auml;emme aina n&auml;yt&ouml;n yl&auml;reunassa.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Console</span></p><p class="c1"><span class="c3">Jos katsot projektin&auml;kym&auml;n yl&auml;reunaan, huomaat sen vieress&auml; lukevan &quot;Console&quot;. Paina t&auml;st&auml;, niin p&auml;&auml;semme konsolin&auml;kym&auml;&auml;n, eli avaamme toisen ikkunan n&auml;kym&auml;&auml;n samasta n&auml;yt&ouml;st&auml;. Konsolin&auml;kym&auml; toimii samoin kuin ohjelmoinnissa k&auml;ytt&auml;m&auml;mme konsoli, eli jos haluamme n&auml;hd&auml; jotain tietty&auml; peliss&auml;, voimme tulostaa sen t&auml;h&auml;n. T&auml;m&auml; on kuitenkin n&auml;kyviss&auml; vain pelin kehitt&auml;j&auml;lle, eli mit&auml;&auml;n pelillisi&auml; ominaisuuksia niin kuin k&auml;ytt&auml;j&auml;n sy&ouml;tett&auml; ei t&auml;h&auml;n voi saada, vaan se on l&auml;hinn&auml; tarkistamaan ett&auml; koodimme toimii oikein.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Asset Store</span></p><p class="c1"><span class="c3">Kun katsomme Scene-n&auml;kym&auml;n yl&auml;reunaan, huomaamme ett&auml; sill&auml;kin on eri ikkunoita. Asset Store avaa Asset kaupan sivun, josta voimme halutessamme ladata ja ostaa assetteja. Koska emme t&auml;t&auml; kuitenkaan halua tehd&auml;, niin voimme klikata sit&auml; oikealla hiirell&auml;, ja painaa &quot;close tab&quot; niin suljemme kyseisen ikkunan. Voitte kuitenkin halutessanne tutkia mit&auml; kaikkea t&auml;&auml;lt&auml; l&ouml;ytyy.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Game</span></p><p class="c1"><span class="c3">Scene-n&auml;kym&auml;n vieress&auml; n&auml;kyy my&ouml;s Game-n&auml;kym&auml;. Kun painamme t&auml;st&auml;, niin n&auml;emme Scenen nyt hieman eri kuvakulmasta emmek&auml; voi liikkua mitenk&auml;&auml;n. T&auml;m&auml; on peli-n&auml;kym&auml;, jossa n&auml;kyy aina se mit&auml; n&auml;kyy Main Camerasta eli p&auml;&auml;kamerasta. Kun testaamme peli&auml;mme, tulemme automaattisesti t&auml;h&auml;n n&auml;kym&auml;&auml;n, ja voimme kokeilla ominaisuuksia joita olemme peliin lis&auml;nneet.</span></p><p class="c1 c10"><span class="c3"></span></p><h2 class="c16" id="h.k4jvuqrz0pa0"><span class="c20">Objektien k&auml;sittely</span></h2><p class="c1"><span class="c9 c7">Objektin luominen</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Nyt kun tied&auml;mme v&auml;h&auml;n mit&auml; n&auml;emme, niin voimme kokeilla jo tehd&auml; jotain. Hierarchy-n&auml;kym&auml;n yl&auml;reunassa lukee &quot;Create&quot;, painakaa t&auml;st&auml; niin meille avautuu valikko eri asioita joita voimme peliin luoda. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 506.00px; height: 505.00px;"><img alt="" src="unity1/images/image5.png" style="width: 506.00px; height: 505.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">Viek&auml;&auml; kursori 3D Object kohdan p&auml;&auml;lle, niin meille avautuu valikko perus 3D objekteista joita voimme luoda. 6 ylint&auml; vaihtoehtoa on kaikkein perinteisimpi&auml; objekteja joita voimme luoda. Paina ylint&auml; vaihtoehtoa eli cube, niin luomme peliin kuution. Kuution nimi &quot;Cube&quot; lukee Hierarchy-n&auml;kym&auml;ss&auml;, ja kuution pit&auml;isi n&auml;ky&auml; my&ouml;s Scene n&auml;kym&auml;ss&auml;. Jos kuutio ei kuitenkaan n&auml;y Scene-n&auml;kym&auml;ss&auml;, niin painakaa kuution nime&auml; Hierarchy-n&auml;kym&auml;ss&auml;, ja katsokaa Inspector n&auml;kym&auml;st&auml; oikealta mik&auml; on kuution position. Jos objektin position on muuta kuin (0,0,0), niin painakaa Transformista hiiren oikealla ja painakaa reset, niin saamme muutettua kaikki arvot nopeasti perusarvoiksi. Viimeist&auml;&auml;n nyt pit&auml;isi laatikon n&auml;ky&auml; keskell&auml; Scene&auml;. Mik&auml;li ei n&auml;y, niin tupla-klikkaamalla kuution nime&auml; Hierarchy-n&auml;kym&auml;ss&auml; p&auml;&auml;semme suoraa siihen miss&auml; kuutio on. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Voimme luoda my&ouml;s objekteja painamalla hiiren oikeaa Hierarchyssa ja valitsemalla haluamamme objekti, tai valitsemalla ikkunan yl&auml;reunasta GameObject ja valitsemalla haluamamme objekti. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Objektin muokkaus</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 185.00px; height: 148.00px;"><img alt="" src="unity1/images/image16.png" style="width: 185.00px; height: 148.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">Voimme helposti liikutella objekteja Sceness&auml; k&auml;ytt&auml;m&auml;ll&auml; ty&ouml;kaluja jotka n&auml;kyv&auml;t Hierarchy-n&auml;kym&auml;n yl&auml;puolella. </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 31.00px; height: 23.00px;"><img alt="" src="unity1/images/image4.png" style="width: 31.00px; height: 23.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>T&auml;m&auml; ty&ouml;kalu toimii t&auml;ysin samoin kuin hiiren keskimm&auml;inen nappi sceness&auml;, mutta nyt hiiren vasemmalla painikkeella. T&auml;m&auml;n pikan&auml;pp&auml;in on </span><span class="c9 c7">&#39;Q&#39;</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 29.00px; height: 22.00px;"><img alt="" src="unity1/images/image18.png" style="width: 29.00px; height: 22.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>T&auml;m&auml; ty&ouml;kalu </span><span>&nbsp;n&auml;ytt&auml;&auml; valitsemamme Objektin sivuille nuolet joista saamme kiinni hiiren vasemmalla n&auml;pp&auml;imell&auml;, ja voimme helposti siirrell&auml; objektia sceness&auml;. T&auml;m&auml;n pikan&auml;pp&auml;in on </span><span class="c9 c7">&#39;W&#39;</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 25.00px; height: 22.00px;"><img alt="" src="unity1/images/image19.png" style="width: 25.00px; height: 22.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>T&auml;m&auml; ty&ouml;kalu </span><span>&nbsp;luo objektin ymp&auml;rille monta eriv&auml;rist&auml; ympyr&auml;&auml;, ja niist&auml; vet&auml;m&auml;ll&auml; hiiren vasemmalla n&auml;pp&auml;imell&auml; saamme k&auml;&auml;nnetty&auml; objektia haluamallamme tavalla. T&auml;m&auml;n pikan&auml;pp&auml;in on </span><span class="c9 c7">&#39;E&#39;</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.00px; height: 21.00px;"><img alt="" src="unity1/images/image3.png" style="width: 27.00px; height: 21.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>T&auml;m&auml; ty&ouml;kalu </span><span>&nbsp;luo objektin ymp&auml;rille kuutioita joista vet&auml;m&auml;ll&auml; saamme helposti muutettua objektin kokoa aina jokaisella akselilla, tai jos ved&auml;mme valkoisesta laatikosta objektin keskelt&auml; saamme muutettua sen kokoa kaikilla akseleilla yht&auml; paljon. T&auml;m&auml;n pikan&auml;pp&auml;in on </span><span class="c9 c7">&#39;R&#39;</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 28.00px; height: 22.00px;"><img alt="" src="unity1/images/image10.png" style="width: 28.00px; height: 22.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>T&auml;m&auml; ty&ouml;kalu </span><span>&nbsp;on my&ouml;s skaalaus ty&ouml;kalu, joka luo objektin reunoille kehikon josta vet&auml;m&auml;ll&auml; voimme muuttaa objektin kokoa. T&auml;m&auml;n pikan&auml;pp&auml;in on </span><span class="c9 c7">&#39;T&#39;</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Emme voi itse objektin ulkomuotoa muuttaa Unityssa, vaan t&auml;h&auml;n tarvitsemme blenderi&auml;. Unityssa itsess&auml;&auml;n voimme vain luoda yksinkertaisia muotoja ja muutta</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 286.00px; height: 206.00px;"><img alt="" src="unity1/images/image13.png" style="width: 286.00px; height: 206.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c9 c7">Objektien lapset</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Voimme laittaa eri objekteja my&ouml;s toisten lapsiksi vet&auml;m&auml;ll&auml; Hierarchyssa objekti toisen objektin p&auml;&auml;lle. T&auml;ll&ouml;in, jos siirr&auml;mme tai muuten muutamme is&auml;nt&auml;-objektia, my&ouml;s kaikki lapsiobjektit muuttuu samalla tavalla.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Objektien tuhoaminen</span></p><p class="c1"><span class="c3">Voimme tuhota objektit painamalla sen nimest&auml; Hierarchy-n&auml;kym&auml;ss&auml; oikealla hiiren painikkeella ja valita delete. </span></p><p class="c1 c10"><span class="c3"></span></p><h2 class="c16" id="h.hfuly9su1pw5"><span class="c20">Pelin testaus</span></h2><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 239.00px; height: 42.00px;"><img alt="" src="unity1/images/image15.png" style="width: 239.00px; height: 42.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">Jotta voimme tehd&auml; pelej&auml;, on meid&auml;n kokeiltava koko ajan ett&auml; se toimii juuri oikein. T&auml;m&auml; onnistuu painamalla oikealla osoittavaa nuolta n&auml;yt&ouml;n yl&auml;reunasta. T&auml;m&auml; k&auml;ynnist&auml;&auml; pelin, ja peli etenee niinkuin se on ohjelmoitu toimimaan. Voit kokeilla jo miten peli k&auml;ynnistyy. Se vaihtaa ikkunan suoraa pelin&auml;kym&auml;&auml;n, ja n&auml;ytt&auml;&auml; mit&auml; kamerasta ikin&auml; n&auml;kyyk&auml;&auml;n. Siell&auml; ei pit&auml;isi n&auml;ky&auml; paljoa, sill&auml; peliss&auml; ei viel&auml; juuri mit&auml;&auml;n ole. Testi loppuu kun painamme nuolesta uudestaan. Kun testi on p&auml;&auml;ll&auml;, kun painamme keskimm&auml;ist&auml; tauko-n&auml;pp&auml;int&auml;, menee testi taukotilaan, jolloin voimme vaihdella objektien paikkaa tai arvoja aloittamatta kokonaan peli&auml; alusta. N&auml;m&auml; arvot eiv&auml;t kuitenkaan ole pysyvi&auml;, ja palautuvat takaisin normaaleihin arvoihin kun lopetamme testi-tilan. Kun olemme tauko-tilassa, painamalla oikeanpuoleisinta n&auml;pp&auml;int&auml;, pystymme kulkemaan peliss&auml; frame kerrallaan, ja katso hyvin tarkkaan, mit&auml; kullakin framella tapahtuu. Useimmissa tapauksissa t&auml;t&auml; ei kuitenkaan tarvitse edes k&auml;ytt&auml;&auml;. Kun tulevissa ohjeissa pyyd&auml;mme testaamaan peli&auml;, paina t&auml;ll&ouml;in vasemman puoleisinta n&auml;pp&auml;int&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><h1 class="c21" id="h.8o0oz9jzoeaj"><span class="c12">Ensimm&auml;inen peli: tasohyppely</span></h1><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt kun tied&auml;mme v&auml;h&auml;n miten unityssa asiat n&auml;kyv&auml;t ja niit&auml; muutettua, niin aloitetaan ensimm&auml;inen projekti. Ei h&auml;t&auml;&auml;, jos projektin aikana tulee jotain mit&auml; ei aijemmin viel&auml; mainittu, niin siit&auml; selitet&auml;&auml;n kyll&auml; paremmin.</span></p><p class="c1 c10"><span class="c3"></span></p><h2 class="c16" id="h.w3cdxlcekf8w"><span class="c20">Pelaaja</span></h2><p class="c1"><span class="c3">Aivan alkuun luodaan pelaaja hahmomme peliin. Luo Sceneen uusi &quot;Plane&quot; objekti, joka toimii pelimme maana v&auml;h&auml;n aikaa. T&auml;m&auml; littana objekti kannattaa siirt&auml;&auml; hieman alas. Sitten luodaan sceneen objekti nimelt&auml; &nbsp;&quot;Capsule&quot; joka luo kapselimaisen objektin sceneen. Nime&auml; objekti uudestaan &quot;pelaaja&quot; nimiseksi Inspector-n&auml;kym&auml;n yl&auml;reunasta. T&auml;m&auml;n j&auml;lkeen hieman alimman komponentin alapuolella pit&auml;isi olla nappi jossa lukee &quot;Add Component&quot;. Paina siit&auml;, niin sinulle avautuu valikko t&auml;ynn&auml; alavalikoita. Etsi alavalikko nimelt&auml;&auml;n &quot;Physics&quot; ja avaa kyseinen alavalikko. T&auml;&auml;lt&auml; etsi sen niminen komponentti kuin &quot;Rigidbody&quot; ja paina siit&auml;. T&auml;m&auml; lis&auml;&auml; kyseisen komponentin objektiimme. Nyt pelaaja hahmostamme pit&auml;isi l&ouml;yty&auml; kaksi t&auml;rkeint&auml; komponenttia mit&auml; Unityss&auml; on, colliderin ja rigidbodyn.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 185.00px; height: 267.85px;"><img alt="" src="unity1/images/image12.png" style="width: 185.00px; height: 267.85px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mik&auml;li vahingossa lis&auml;simme jonkin komponentin mit&auml; emme halunneet, siirr&auml; kursori komponentin nimen p&auml;&auml;lle, paina vasenta hiirt&auml; ja paina &quot;Remove Component&quot;. T&auml;m&auml; poistaa komponentin objektista, mik&auml;li se on vain mahdollista, mutta esimerkiksi transform-komponenttia ei voi poistaa milt&auml;&auml;n objektilta.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 204.00px;"><img alt="" src="unity1/images/image6.png" style="width: 432.00px; height: 204.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c9 c7">Rigidbody</span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span class="c3">Rigidbody lis&auml;&auml; fysiikat objektillemme, eli nyt objektiimme vaikuttaa painovoima, ja muut objektit vaikuttavat siihen t&ouml;rm&auml;tess&auml;. Voimme komponentin arvoja halutessamme</span></p><p class="c1"><span class="c3">.</span></p><p class="c1"><span>Ensimm&auml;isen&auml; on objektin </span><span class="c7">Mass</span><span class="c3">, eli kuinka paljon objekti painaa. T&auml;ll&auml; ei ole niin paljoa v&auml;li&auml;, koska pelaaja tulee luultavasti olemaan ainut objekti jolla on paino. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 26.70px; height: 30.31px;"><img alt="" src="unity1/images/image2.png" style="width: 26.70px; height: 30.31px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 26.70px; height: 30.31px;"><img alt="" src="unity1/images/image2.png" style="width: 26.70px; height: 30.31px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c7">Drag</span><span class="c3">&nbsp;jonka arvoa muuttamalla saamme hidastettua objektin liikett&auml;. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c7">Angular Drag</span><span class="c3">&nbsp;joka muuttaa objektin py&ouml;rimisnopeutta. </span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span class="c7">&quot;Use Gravity</span><span class="c3">&quot;. Jos t&auml;m&auml; on p&auml;&auml;ll&auml; niin objektiin vaikuttaa painovoima, jos taas ei niin objekti leijuu ilmassa. T&auml;m&auml; pit&auml;&auml; olla ruksittuna. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>&quot;</span><span class="c7">Is Kinematic</span><span class="c3">&quot;. Jos t&auml;m&auml; on p&auml;&auml;ll&auml; niin objekti on kinemaattinen, eli vaikuttaako Rigidbody-komponentin mitk&auml;&auml;n asetukset viel&auml; objektiin. T&auml;ll&auml; voimme helposti m&auml;&auml;ritell&auml; objektille painovoiman valmiiksi, ilman ett&auml; se vaikuttaa objektiin tietyiss&auml; tilanteissa. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Seuraavaan vaihtoehtoon joka on &quot;</span><span class="c7">Interpolate</span><span>&quot;, voit tutustua enemm&auml;n </span><span class="c19"><a class="c18" href="https://www.google.com/url?q=https://docs.unity3d.com/ScriptReference/Rigidbody-interpolation.html&amp;sa=D&amp;ust=1503671713061000&amp;usg=AFQjCNEhQlPxtjSuRac113VXJHrpfYz9fw">t&auml;&auml;lt&auml;</a></span><span class="c3">. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>&quot;</span><span class="c7">Collision Detection</span><span>&quot;, tarkoittaa miten t&auml;m&auml; objekti osuu muihin objekteihin, ja sit&auml; k&auml;ytet&auml;&auml;n hy&ouml;dyksi nopeasti liikkuvien objektien kanssa. Discrete ei vaikuta objektin normaaliin toimintaan mitenk&auml;&auml;n. Kaksi muuta vaihtoehtoa, &quot;</span><span>Continuou</span><span>s&quot; ja &quot;Continuous Dynamic&quot; on luotu juuri nopeasti liikkuviin objekteihin etteiv&auml;t ne mene toistensa l&auml;pi. Aseta nopeasti liikkuvaan objektiin t&auml;m&auml;n arvoksi &quot;</span><span class="c7">Continuous Dynamic</span><span>&quot;, ja muihin objekteihin joiden l&auml;pi t&auml;m&auml; objekti ei saa menn&auml;, aseta arvoksi &quot;</span><span class="c7">Continuous</span><span>&quot;. T&auml;ss&auml; peliss&auml; meill&auml; eiv&auml;t objektit kuitenkaan kulje niin nopeaa, joten t&auml;h&auml;n arvoksi saa j&auml;&auml;d&auml; &quot;</span><span class="c7">Discrete</span><span class="c3">&quot;</span></p><p class="c1"><span class="c3">. </span></p><p class="c1"><span>Viimeiseksi meill&auml; on aukaistavana alavalikko &quot;</span><span class="c7">Constraints</span><span>&quot;, eli rajoitukset. T&auml;&auml;ll&auml; voimme asettaa ettei painovoima tai fysiikat vaikuta objektiin, ylemp&auml;n&auml; objektin paikkaan, ja alempana objektin k&auml;&auml;ntyvyyteen. Asetamme fysiikat vaikuttamaan objektin k&auml;&auml;ntymiseen, eli laitamme ruksin </span><span class="c7">Freeze Rotation</span><span>:n kohtiin </span><span class="c7">X</span><span>, </span><span class="c7">Y</span><span>&nbsp;ja </span><span class="c7">Z</span><span class="c3">.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 431.00px; height: 155.00px;"><img alt="" src="unity1/images/image14.png" style="width: 431.00px; height: 155.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Collider</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Collider on periaatteessa suojakehikko joka pit&auml;&auml; huolen ettei objektit mene p&auml;&auml;llekk&auml;in. Collidereita on monenlaisia ja muotoisia, ja niit&auml; kannattaakin v&auml;h&auml; kokeilla aina tilanteesta riippuen mik&auml; on paras. Collider siis pit&auml;&auml; huolen ett&auml; objektimme on mahdollista t&ouml;rm&auml;t&auml; muihin objekteihin. Voimme halutessamme muuttaa colliderin koon sopivaksi, mutta t&auml;ll&auml; kertaa muuhun ei tarvitse koskea. &quot;Is Trigger&quot; ruksista ja &quot;Material&quot; kohdasta kerrotaan tarkemmin my&ouml;hemmin ohjeissa.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Voit kokeilla Rigidbodyn ja colliderin toimintaa peliss&auml;. Lis&auml;&auml; sceneen kaksi tavallista objektia kuten kuutiota, ja aseta toinen p&auml;&auml;lle ja toinen hieman ensimm&auml;isen alapuolelle. Lis&auml;&auml; ylemp&auml;&auml;n Rigidbody. Molemmissa pit&auml;isi olla jo valmiina BoxColliderit, eli laatikon muotoiset colliderit. Nyt kun painamme play, ylemp&auml;&auml;n objektiin alkaa painovoima vaikuttaa, ja se alkaa tippua alas p&auml;in, kun taas alempi objekti j&auml;&auml; paikoilleen, koska siit&auml; puuttuu rigidbody. Ylempi objekti my&ouml;s t&ouml;rm&auml;&auml; alempaan objektiin ja lopettaa tippumisen, koska molemmilla on colliderit. Nyt jos otamme toisesta objektista colliderin pois, ja teemme saman testin uudelleen, ne eiv&auml;t en&auml;&auml; t&ouml;rm&auml;&auml; toisiinsa, vaan laatikko vain jatkaa tippumistaan.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Objektissamme oli valmiiksi jo CapsuleCollider, joka on juuri hyv&auml; pelaajahahmon luomiseen, sill&auml; se ei todenn&auml;k&ouml;isesti j&auml;&auml; jumiin minnekk&auml;&auml;n.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Objektissamme on my&ouml;s &quot;</span><span class="c7">MeshFilter</span><span>&quot; ja &quot;</span><span class="c7">MeshRenderer</span><span class="c3">&quot; komponentit. N&auml;iden avulla n&auml;emme pelaajahahmomme sceness&auml;. MeshFilter m&auml;&auml;rittelee mink&auml;lainen mesh objektissamme on, eli milt&auml; objektimme n&auml;ytt&auml;&auml;. T&auml;ll&auml; kertaa siell&auml; pit&auml;isi l&auml;hinn&auml; lukea Capsule. MeshRenderer on se joka saa objektimme n&auml;kyv&auml;ksi, eli &quot;render&ouml;i&quot; objektimme. T&auml;&auml;ll&auml; voimme muuttaa asetuksia jotta objekti render&ouml;id&auml;&auml;n eri tavalla, eli ett&auml; se n&auml;ytt&auml;isi hieman erilaiselta. Koska objekti on pelaajahahmo, ja teemme t&auml;st&auml; tasohyppelyst&auml; ensimm&auml;isen persoonan pelin, poistame kyseiset komponentit. Mutta testitarkoituksessa on hyv&auml; ett&auml; viel&auml; n&auml;emme objektimme, eli j&auml;tet&auml;&auml;n komponentit n&auml;in. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Scriptin luominen</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Luo project-n&auml;kym&auml;ss&auml; uusi kansio, ja anna sille nimeksi esimerkiksi scriptit. Avaa kansio, paina hiiren vasemmalla, valitse &quot;</span><span class="c7">Create</span><span>&quot;, paina kohdasta &quot;</span><span class="c7">C# Script</span><span>&quot; ja nime&auml; scripti nimell&auml; &quot;</span><span class="c7">liikkuminen</span><span>&quot;. N&auml;in olemme luoneet ensimm&auml;isen ohjelmamme peliin, mutta t&auml;m&auml; ei viel&auml; tee mit&auml;&auml;n. Avaa koodi tuplaklikkaamalla siit&auml;. Koodin tulisi aueta erillisess&auml; koodin muokkaus ohjelmassa, joka on luultavasti &quot;</span><span class="c7">Visual Studio</span><span class="c3">&quot;. T&auml;m&auml; on koodin muokkaus ohjelma jotka toimivat v&auml;h&auml;n samalla tavoin kuin k&auml;ytt&auml;m&auml;mme nettisivu c# harjoituksissa. Visual Studio asentuu samalla kun asensimme Unityn koneellemme. Jotta voimme k&auml;ytt&auml;&auml; Visual Studiota, tulisi meid&auml;n taas kirjautua visual studioon k&auml;ytt&auml;j&auml;ll&auml;mme. Mik&auml;li teill&auml; ei ole microsoft/outlook/hotmail tili&auml;, niin joudumme menn&auml; taas nettiin luomaan itsellemme sellaiset. Onneksi meid&auml;n ei tarvitse luoda koko s&auml;hk&ouml;postia, vain yhdist&auml;&auml; jo olemassa oleva s&auml;hk&ouml;posti outlookiin.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Kun olemme kirjautuneet sis&auml;&auml;n, niin huomaamme ett&auml; koodi n&auml;ytt&auml;&auml; hieman erillaiselta mit&auml; olemme c# teht&auml;viss&auml; tottuneet k&auml;ytt&auml;m&auml;&auml;n. Alussa on perinteisen kirjaston lis&auml;ksi otettu kaksi unityn omaa kirjastoa k&auml;ytt&ouml;&ouml;n. N&auml;iden avulla pystymme k&auml;ytt&auml;m&auml;&auml;n paremmin unityn omia ominaisuuksia hy&ouml;dyksi. Seuraavaksi luodaan classi, ja sen nimeksi annettiin automaattisesti sama mink&auml; annoit tiedostolle nimeksi. T&auml;m&auml;n j&auml;lkeen tulee 2 meille ennen n&auml;kem&auml;t&ouml;nt&auml; metodia nimelt&auml; &quot;</span><span class="c7">Start</span><span>&quot; ja &quot;</span><span class="c7">Update</span><span class="c3">&quot;. N&auml;m&auml; ovat unityn omia metodeja jotka se tunnistaa, ja k&auml;ytt&auml;&auml; tietyll&auml; tavalla. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Start-metodissa olevat koodit unity suorittaa kaikkein ensimm&auml;isen&auml; kun objekti luodaan. T&auml;nne kannattaa laittaa muuttujien perusarvojen asettaminen.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Update-metodissa olevat koodit unity suorittaa joka framella, eli koko ajan. T&auml;nne laitetaan pelin kaikki pelilliset ominaisuudet, kuten n&auml;pp&auml;inten painalluksien tunnistus ja liikkuminen, sek&auml; muita vastaavia asioita.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Testataan aluksi ett&auml; kaikki toimii oikein. Kirjoita Update-methodin sis&auml;&auml;n:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.592abbcd9402e35c8b6dd4f3bf0a367899474d1b"></a><a id="t.0"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c3">int i=0;</span></p><p class="c1"><span class="c3">print(&quot;TOIMIIIII &quot;+i); </span></p><p class="c1"><span class="c3">i++;</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">T&auml;m&auml; tulostaa konsoliin printin sis&auml;ll&ouml;n, samalla tavoin kuin Console.WriteLine(); tekee tavallisessa c# ohjelmassa. T&auml;&auml;ll&auml; meill&auml; ei kuitenkaan ole normaalia konsolia, vain unityn oma konsoli k&auml;yt&ouml;ss&auml;, joten joudumme k&auml;ytt&auml;&auml; t&auml;t&auml; koodia asioiden tulostamiseen. T&auml;ss&auml; my&ouml;s n&auml;emme kuinka usein Update-methodia kutsutaan. Testatkaa siis mit&auml; tapahtuu kun nyt painamme play-nappia. Ja muistakaa, aina kun teemme koodiin jotain muutoksia, muistakaa tallentaa kaikki muutokset, tai muuten koodi ei toimi oikein. T&auml;m&auml; onnistuu nopeiten CTRL+S n&auml;pp&auml;in yhdistelm&auml;ll&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Peliss&auml; ei pit&auml;isi tapahtua mit&auml;&auml;n, tai ei ainakaan konsoliin. T&auml;m&auml; johtuu siit&auml;, ett&auml; tekem&auml;mme koodi ei ole viel&auml; peliss&auml;. Loimme kyll&auml; project-kansioon koodin, mutta meid&auml;n on asetettava se jollekkin objektille, ennen kuin se tekee peliss&auml; yht&auml;&auml;n mit&auml;&auml;n. Lis&auml;t&auml;&auml;n siis koodi pelaaja-objektiimme. T&auml;m&auml; onnistuu samalla tavalla kuin muidenkin komponenttien lis&auml;&auml;minen, eli painamalla Add Component, sielt&auml; ala-valikko scripts ja scriptimme nimi. Voimme my&ouml;s asettaa koodin suoraa objektiin vet&auml;m&auml;ll&auml; koodin project-kansiosta Hierarchyyn haluamamme objektin p&auml;&auml;lle. Nyt kun kokeilemme peli&auml;, pit&auml;isi konsoliin tulostua TOIMIIII ja aina kuinka mones tulostus se on. Jos lis&auml;&auml;mme saman koodin johonkin toiseen obejktiin, huomaamme ett&auml; nyt kaikki tulostuu kaksi kertaa. Koodi ei v&auml;lit&auml; vaikka sama koodi olisi jo toisessakin objektissa, se tekee sen mit&auml; se on ohjelmoitu tekem&auml;&auml;n, joten jos samaa koodia on monessa eri paikassa, se tekee samat asiat useaan kertaan. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Mutta, aloitetaan koodin teko. Tasohyppelyn ohjelmointi on </span><span>helppoa</span><span class="c3">, koska siihen tarvitaan l&auml;hinn&auml; c# teht&auml;viss&auml; opittuja if-lausekkeita. Aloitetaankin laittamalla if-lauseke Update methodin sis&auml;&auml;n, ja laitetaan se tapahtumaan aina kun Inputista l&ouml;ytyv&auml; axis nimelt&auml;&auml;n &quot;Horizontal&quot; on muuta kuin 0. Koodi siis n&auml;ytt&auml;&auml; t&auml;lt&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.4cc63ab5e1d0b27050ac1bcfa9cace9702458cd0"></a><a id="t.1"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">if(Input.GetAxis(&quot;Horizontal&quot;)!=0){</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Katsotaan hieman mit&auml; koodi pit&auml;&auml; sis&auml;ll&auml;&auml;n.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Input</span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span>Input on unityn omia muuttujia, jonka avulla voimme lukea kaikki k&auml;ytt&auml;j&auml;n painamat n&auml;pp&auml;imet, jos haluamme. T&auml;ll&auml; kertaa haluamme Input:tista Axis eli akselin nimelt&auml;&auml;n &quot;</span><span class="c7">Horizontal</span><span class="c3">&quot;. Mit&auml; t&auml;m&auml; tarkoittaa on se, ett&auml; ohjelma katsoo koko ajan olemmeko painaneet oikealle tai vasemmalle nuolta, tai A tai D. Voisimme asettaa ohjelman tunnistamaan tarkalleen n&auml;m&auml; n&auml;pp&auml;imist&ouml;n painallukset, mutta t&auml;m&auml; koodi on parempi, sill&auml; tunnistaa my&ouml;s tatin ja nuolten n&auml;pp&auml;imet mik&auml;li pelaaja k&auml;ytt&auml;&auml;kin peliohjainta. Input.GetAxis(&quot;Horizontal&quot;) antaa ohjelmalle numeron, joka on v&auml;lill&auml; -1 ja 1. Mik&auml;li pelaaja ei yrit&auml; liikkua sivuille, antaa t&auml;m&auml; ohjelmaan 0. Jos pelaaja yritt&auml;&auml; liikkua vasemmalle, antaa t&auml;m&auml; -1, ja jos oikealle, niin 1. Jos pelaaja k&auml;ytt&auml;&auml; tattia, antaa t&auml;m&auml; hieman tarkemman luvun sit&auml; mukaa kuinka kauas h&auml;n tattia siirt&auml;&auml;. Koska luku on 0 vain silloin kun ei edes yritet&auml; liikkua, laitetaan if-lauseke tarkistamaan onko arvo 0, ja jos ei ole, pelaaja yritt&auml;&auml; liikkua joten laitetaan hahmo liikkumaan.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">transform</span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span>Laitetaan nyt koodia if-lausekkeeseen. </span><span class="c3">Kuten aijemmin mainittiin, jokaisessa objektissa on transform-komponentti joka sis&auml;lt&auml;&auml; kaikki objetkin paikka tiedot. Voimme muokata n&auml;it&auml; arvoja helposti koodissa, k&auml;ytt&auml;m&auml;ll&auml; pelk&auml;st&auml;&auml;n sanaa transform, jolloin p&auml;&auml;semme k&auml;siksi sen objektin transformiin johon koodi on lis&auml;tty. Kirjoittamalla esimerkiksi transform.position pystymme muuttamaan objektin paikkaa. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Vector3</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Unity pelimoottori k&auml;ytt&auml;&auml; paljon Vector3 arvoja. Vector3 on kolmesta float-arvosta koottu muuttuja, jota k&auml;ytet&auml;&auml;n esimerkiksi objektien kohdan muuttamiseen. Vector3 siis sis&auml;lt&auml;&auml; aina x,y ja z arvon t&auml;ss&auml; j&auml;rjestyksess&auml;. Voimme luoda uuden Vector3:sen kirjoittamalla &quot;new Vector3(x,y,z)&quot; jossa x,y,z ovat haluamamme arvot. Voimme my&ouml;s k&auml;ytt&auml;&auml; valmiiksi tallennettuja arvoja, kuten esimerkiksi &quot;Vector3.right&quot; joka antaa automaattisesti arvot (1,0,0).</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kirjoitetaan siis koodiin if-lauseen aaltosulkeiden sis&auml;lle:</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">transform.position+=Vector3.right*Input.GetAxis(&quot;Horizontal&quot;);</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kuten arvata saattaa, koodi lis&auml;&auml; transform.positioniin Vector3.right, eli (1,0,0). Me kuitenkin kerromme t&auml;m&auml;n arvon ensin Input.GetAxis(&quot;Horizontal&quot;) arvolla, mik&auml; mahdollistaa sek&auml; vasempaan ett&auml; oikeaan menemisen, koska arvo voi olla miinus-lukuinen. Input.GetAxis arvolla kertominen my&ouml;s mahdollistaa nopeuden s&auml;&auml;t&auml;misen jos pelaaja pelaa ohjaimella tateilla. Eli nyt pystymme liikkumaan sivuille.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kopioidaan juuri tekem&auml;mme koodi, ja pastetaan se sen alapuolelle, ett&auml; meill&auml; on kaksi samann&auml;k&ouml;ist&auml; koodia per&auml;kk&auml;in. T&auml;m&auml;n j&auml;lkeen, muokkaa j&auml;lkimm&auml;ist&auml; siten, ett&auml; kaikki miss&auml; lukee &quot;Horizontal&quot; on nyt &quot;Vertical&quot;, ja Vector3.right onkin nyt Vector3.forward. N&auml;in tekem&auml;ll&auml; pystymme nyt liikkumaan my&ouml;s eteen ja taakse. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt jos testaamme peli&auml;, niin n&auml;emme pelaajahahmomme liikuvan sinne minne painamme.. Liike saattaa olla hieman nopea peliimme, joten voimme lis&auml;t&auml; /4 tekemiemme koodien loppuun, ett&auml; t&auml;m&auml; nopeus jaetaan nelj&auml;ll&auml;. Voitte itse s&auml;&auml;t&auml;&auml; nopeuden kuten haluatte. Koodin tulisi siis nyt n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.e9a03e08fb9d1599c5cd3cef8869f22a52f6131e"></a><a id="t.2"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">void Update () {</span></p><p class="c1 c11"><span class="c0">if (Input.GetAxis(&quot;Horizontal&quot;) != 0)</span></p><p class="c1 c11"><span class="c0">{</span></p><p class="c1 c5"><span class="c0">transform.position += Vector3.right * Input.GetAxis(&quot;Horizontal&quot;)/4;</span></p><p class="c1 c11"><span class="c0">}</span></p><p class="c1 c11"><span class="c0">if (Input.GetAxis(&quot;Vertical&quot;) != 0)</span></p><p class="c1 c11"><span class="c0">{</span></p><p class="c1 c5"><span class="c0">transform.position += Vector3.forward * Input.GetAxis(&quot;Vertical&quot;) / 4;</span></p><p class="c1 c11"><span class="c0">}</span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt meill&auml; on pelaajan liikkuminen, mutta kamera ei seuraa pelaajaa. T&auml;m&auml; korjataan helposti asettamalla kamera pelaajan lapseksi, vet&auml;m&auml;ll&auml; Hierarchy-n&auml;kym&auml;ss&auml; Main Camera-objekti pelaaja-objektin nimen p&auml;&auml;lle. Nyt kun testaamme peli&auml;, niin kamera seuraa pelaajaa koko ajan. Koska peli on ensimm&auml;isen persoonan peli, niin muutetaan kameran position arvot olemaan (0,0.5,0), jolloin kamera on melkein objektin keskell&auml;, mutta hieman ylemp&auml;n&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt meill&auml; on hyv&auml; liikkuminen tehtyn&auml;, mutta ei viel&auml; t&auml;ydellinen, sill&auml; kamera katsoo koko ajan vain yhteen suuntaan. Joten seuraavaksi, siirryt&auml;&auml;n takaisin koodiin ja laitetaan hiiri muuttamaan kameran katsomissuuntaa ett&auml; voimme liikkua ymp&auml;riins&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kirjoitetaan uusi if-lause, joka on samann&auml;k&ouml;inen kuin aiemminkin, mutta nyt se etsii &quot;Horizontal&quot; ja &quot;Vertical&quot; akselin sijaan akselin &quot;Mouse Y&quot;. N&auml;in saamme hiiren yl&ouml;s-alas liikkumisen -1 ja 1 v&auml;lilt&auml;. Emme halua ett&auml; koko objekti kallistuu kun katsomme yl&ouml;s ja alas koska t&auml;ll&ouml;in kameran kulma olisi aivan v&auml;&auml;r&auml; ja se n&auml;ytt&auml;isi muutenkin oudolta. Haluamme vain ett&auml; kamera kallistuu, joten sen sijaan ett&auml; kirjoittaisimme pelk&auml;n transformin koodiin, kirjoitamme Camera.main.transform joka etsii automaattisesti p&auml;&auml;kameran kent&auml;lt&auml; ja muuttaa t&auml;m&auml; transform arvoja. T&auml;ll&auml; kertaa haluamme vain k&auml;&auml;nt&auml;&auml; kameraa, emme siirt&auml;&auml; sit&auml;, joten positionin sijaan kirjoitamme .eulerAngles joka tarkoittaa juuri objektin (x,y,z) k&auml;&auml;ntymisarvoja.</span></p><p class="c1"><span>Lis&auml;t&auml;&auml;n eulerAngles-arvoihin Vector3.right*Input.GetAxis(&quot;Mouse Y&quot;); jolloin kun siirr&auml;mme hiirt&auml; alas pelaaja katsoo yl&ouml;s, ja kun siirr&auml;mme hiirt&auml; alas niin pelaaja yl&ouml;s. Eli nyt koodi n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.fbe3ba13bb177e00236a2d01e35f8f6bcb8a9a83"></a><a id="t.3"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c3">if(Input.GetAxis(&quot;Mouse Y&quot;) != 0)</span></p><p class="c1"><span class="c3">{</span></p><p class="c1"><span class="c3">&nbsp; &nbsp; &nbsp; Camera.main.transform.eulerAngles += Vector3.right * Input.GetAxis(&quot;Mouse Y&quot;);</span></p><p class="c1"><span class="c3">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mik&auml;li haluamme ett&auml; hiiri toimii toisin p&auml;in, ett&auml; kun hiirt&auml; siirt&auml;&auml; yl&ouml;sp&auml;in pelaaja katsoo yl&ouml;sp&auml;in ja niin edelleen, (niinkuin min&auml; itse ainakin haluan) vaihdeteen koodiin &quot;+=&quot; sijaan &quot;-=&quot;. Nyt hiiren pit&auml;isi toimi oikein.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Tehd&auml;&auml;n taas kuten aijemmin, ja copypastetetaan juuri tekem&auml;mme koodi aijemman alapuolelle, ja muutetaan kaikki &quot;Mouse Y&quot; kohdat olemaan &quot;Mouse X&quot;, ja Vector3.right olemaan Vector3.up. otetaan my&ouml;s Camera.main. kokonaan pois, sill&auml; kun katsomme sivuille, haluamme ett&auml; koko pelaaja katsoo sivulle, ei vain kamera.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Eli nyt koko koodin tulisi n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.e053aedf26b9a3e9c6bfab9df79876e812ab8259"></a><a id="t.4"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">if (Input.GetAxis(&quot;Horizontal&quot;) != 0)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1 c23"><span class="c0">transform.position += Vector3.right * Input.GetAxis(&quot;Horizontal&quot;)/4;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">if (Input.GetAxis(&quot;Vertical&quot;) != 0)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1 c23"><span class="c0">transform.position += Vector3.forward * Input.GetAxis(&quot;Vertical&quot;) / 4;</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">if(Input.GetAxis(&quot;Mouse Y&quot;) != 0)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1 c11"><span class="c0">Camera.main.transform.eulerAngles -= Vector3.right * Input.GetAxis(&quot;Mouse Y&quot;);</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">if (Input.GetAxis(&quot;Mouse X&quot;) != 0)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1 c23"><span class="c0">transform.eulerAngles += Vector3.up * Input.GetAxis(&quot;Mouse X&quot;);</span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Jos kokeilemme peli nyt, niin koodi toimii melkein oikein. Melkein. Pelaajahahmo kyll&auml; kulkee eteen ja taakse sek&auml; sivuille, ja katsoo yl&ouml;s ja alas sek&auml; sivuille, mutta jos katsomme sivuille niin pelaajahahmo jatkaa samaan suuntaan menemist&auml;, eik&auml; koko ajan suoraa niinkuin peliss&auml; haluaisimmekin. T&auml;m&auml; on kuitenkin helposti korjattu. Etsi kohdat jossa muutamme pelaaja hahmon positionia, siell&auml; pit&auml;isi lukea Vector3.right sek&auml; Vector3.forward. Muuta n&auml;m&auml; olemaan transform.right ja transform.forward. Koska Vector3 arvot ovat aina samanlaisia, ne siirt&auml;v&auml;t aina samaan suuntaan, mutta kun otamme samat arvot transformista, se antaa haluamamme suunnan objektista katsottuna, toisin sanoen se palauttaa esimerkiksi aina objektista katsottuna oikeaan menev&auml;n arvon. T&auml;m&auml;n takia halusimme my&ouml;s muuttaa koko pelaajaobjektimme eulerAngles-arvoa kun katsomme sivulle, tai muuten t&auml;m&auml; ei toimi.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt kun vaihdoimme Vector3:n tilalle transform, pit&auml;isi ohjauksen toimia t&auml;ydellisesti. Peli on kuitenkin viel&auml; hieman outo, sill&auml; vaikka peli on ensimm&auml;isest&auml; persoonasta, n&auml;emme hiiren liikkuvan haluamaamme suuntaan. T&auml;m&auml; saadaan korjattua kirjoittamalla Start() methodiin</span></p><p class="c1"><span class="c3">&nbsp;</span></p><a id="t.77c79e71642c7d6ae05e398d362f8bb21f05b379"></a><a id="t.5"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">Cursor.lockState = CursorLockMode.Locked; </span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">T&auml;m&auml; piilottaa kursorin n&auml;kyvist&auml; aivan pelin alussa, ja lukitsee sen n&auml;yt&ouml;n keskelle. Saamme sen vapautettua painamalla esc-n&auml;pp&auml;int&auml; n&auml;pp&auml;imist&ouml;lt&auml;. Mutta kun vapautamme kursorin, emme saa sit&auml; takaisin piiloon, joten lis&auml;t&auml;&auml;n koodiin ett&auml; saamme klikkaamalla peli&auml; hiirell&auml; kursorin takaisin piiloon. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kirjoitetaan Update() methodiin uusi if-lauseke, mutta t&auml;ll&auml; kertaa kirjoitetaan sinne Input.GetMouseButtonDown(0). T&auml;m&auml; saa Inputista t&auml;ll&auml; kertaa tiedon, onko hiiren vasenta n&auml;pp&auml;int&auml; painettu. Jos on, niin se suorittaa koodin if-lausekkeen sis&auml;ll&auml;. Jos haluamme t&auml;m&auml;n toimivan hiiren vasemmalla n&auml;pp&auml;imell&auml;, laitetaan sulkuihin 0 sijaan 1, ja jos hiiren keskimm&auml;isell&auml;, niin laitetaan sulkuihin 2. Sijoitetaan if-lausekkeen sis&auml;&auml;n sama koodin p&auml;tk&auml; mink&auml; laitoimme Start()-methodiinkin.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Eli nyt meill&auml; on kaikkein t&auml;rkeimm&auml;t laitettu, joten eik&ouml;h&auml;n vihdoin aseteta peliin hyppy-toiminto. Luodaan Update-methodiin viel&auml; yksi if-lauseke, ja tarkistetaan Input.GetButtonDown(&quot;Jump&quot;). Kuten akselinkin kanssa, t&auml;m&auml; etsii painetaanko yleist&auml; hyppynappia, joka n&auml;pp&auml;imist&ouml;ll&auml; on v&auml;lily&ouml;nti, ja ohjaimella joku omansa. Laita if-lausekkeen sis&auml;&auml;n </span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.df2aa44e0829bc584ca7e471629c2f80f955c5a0"></a><a id="t.6"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">GetComponent&lt;Rigidbody&gt;().velocity=Vector3.up*3; </span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">GetComponent&lt;&gt;()</span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span class="c3">GetComponent on yksi t&auml;rkeimpi&auml; asioita mit&auml; Unitylla ohjelmoinnissa k&auml;yt&auml;mme. GetComponent on lauseke jolla saamme mink&auml; tahansa haluamamme komponentin objektista, kunhan komponentti on objektissa olemassa. Muuten se antaa virheilmoituksen. Haluamamme komponentin nimi laitetaan &lt;&gt; v&auml;liin, ja tavalliset sulkeet j&auml;tet&auml;&auml;n aina tyhj&auml;ksi.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mit&auml; haluamme tehd&auml;, on lis&auml;t&auml; objektiin yl&ouml;smenev&auml;&auml; voimaa, niinkuin se hypp&auml;isi yl&ouml;sp&auml;in. Teemme t&auml;m&auml;n vaikuttamalla objektin fysiikkaan, ja koska Rigidbody-komponentti tekee kaiken fysiikan objektiin, k&auml;yt&auml;mme getcomponenttia saadaksemme Rigidbodyn. Rigidbody-komponentilla on velocity arvo, joka antaa voimat johon objektin fysiikat t&auml;t&auml; liikuttavat. Jos kokeilemme laittaa t&auml;m&auml;n printtiin, kuten:</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">print(GetComponent&lt;Rigidbody&gt;().velocity);</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">niin saisimme luultavasti arvot jotka muistuttavat (0,-1,0), koska fysiikan painovoimat painavat sit&auml; koko ajan alasp&auml;in. Mutta jos asetammekin Velocityyn arvon joka ty&ouml;nt&auml;&auml; objektia yl&ouml;sp&auml;in, saamme luotua realistisen tuntuisen hypyn. Nyt koodimme asettaa yl&ouml;sp&auml;invoimaa 3, mutta voimme muokata kolmosen tilalle mink&auml; tahansa haluamamme numeron, joka s&auml;&auml;t&auml;&auml; kuinka voimakas hyppy on. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt meill&auml; on hyppy, mutta peliss&auml;mme saattaa olla paljon korkeita paikkoja, mit&auml; jos haluamme tuplahypyn? T&auml;m&auml; onnistuu luomalla int muuttuja ennen Start methodia, jonka nimeksi voimme asettaa vaikka &nbsp;&quot;hypyt&quot;, ja sen arvoksi 0. Eli siis se n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.b8b9a185430cb3036dd219dec338789538a09650"></a><a id="t.7"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">int hypyt = 0;</span></p><p class="c1"><span class="c0">void Start () {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Koska luomme int muuttujan tuossa kohtaa, emmek&auml; esim Update methodin sis&auml;ll&auml;, muuttujan arvot pysyv&auml;t koko ajan samana kun me sen asetamme. Jos loisimme muuttujan Update methodissa, arvo palaisi nollaksi koko ajan, koska update methodi suoritetaan joka framella, jolloin se palauttaa sille sen perusarvon eli 0. Nyt vain suoraan tekem&auml;mme muutokset muuttavat hypyt muuttajaa.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Teimme if-lausekkeen joka tarkistaa onko &quot;Jump&quot; nappia painettu. Menn&auml;&auml;n takaisin t&auml;h&auml;n, ja laitetaan kyseinen if-lauseke tarkistamaan my&ouml;s, ettei hypyt-muuttuja ole esimerkiksi 2. Meh&auml;n saamme if-lausekkeen tarkistamaan toisenkin arvon k&auml;ytt&auml;m&auml;ll&auml; &amp;&amp;, ja saamme tarkistettua ettei hypyt ole 2 kirjoittamalla hypyt!=2. lis&auml;&auml;mme my&ouml;s if-lausekkeen sis&auml;kke hypyt++; joka lis&auml;&auml; hypyt-muuttujaan nyt aina yhden lis&auml;&auml; kun hypp&auml;&auml;mme. Eli nyt, if-lausekkeen tulisi n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.32f2a05912ab317bf2bc4aa2382d65bfcdc20f7e"></a><a id="t.8"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">if (Input.GetButtonDown(&quot;Jump&quot;)&amp;&amp; hypyt!=2)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; GetComponent&lt;Rigidbody&gt;().velocity = Vector3.up * 3;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; hypyt++;</span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kuten varmaan voitte arvata, nyt pystymme hypp&auml;&auml;m&auml;&auml;n vain kaksi kertaa. Nyt ongelmana on, miten saamme tunnistettua onko pelaajahahmo osunut maahan, jolloin hypyt-muuttuja palaa nollaksi, ett&auml; voimme taas hyppi&auml; kaksi kertaa.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">T&auml;m&auml; onnistuu luomalla Unityn oman metodin OnCollisionStay. T&auml;m&auml;n sijoitamme void Update() -lohkon alapuolelle.</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.701d6645daf8984551c79fddee53d0f9d09ec792"></a><a id="t.9"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">void OnCollisionStay(Collision col){}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">OnCollision</span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span class="c3">Unityssa on t&ouml;rm&auml;yksen tunnistus mekaniikkansa, johon p&auml;&auml;semme k&auml;siksi k&auml;ytt&auml;m&auml;ll&auml; OnCollision-methodeja. N&auml;it&auml; methodeja on 3 erillaista. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c7">OnCollisionEnter</span><span class="c3">, jota kutsutaan silloin kun objektimme osuu uuteen objektiin. T&auml;t&auml; methodia kutsutaan kerran juuri silloin kun objekti t&ouml;rm&auml;&auml; toiseen. Jos objektit pysyv&auml;t toisissaan kiinni, ei t&auml;t&auml; methodia kutsuta yht&auml; kertaa enemp&auml;&auml;. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c7">OnCollisionStay,</span><span class="c3">&nbsp;jota kutsutaan niin kauan kun objekti osuu toiseen objektiin. T&auml;t&auml; methodia kutsutaan niin kauan kun objektit koskettavat toisiaan.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c7">OnCollisionExit</span><span class="c3">, jota kutsutaan silloin kun objektimme erkaantuvat toisistaan. T&auml;t&auml; methodia kutsutaan kerran juuri silloin, kun kaksi objektia irtoavat toisistaan.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Jotta mit&auml;&auml;n n&auml;ist&auml; methodeista kutsutaan, on molemmissa objekteissa jotka t&ouml;rm&auml;&auml;v&auml;t oltava jonkinlainen Collider, ja edes toisessa on oltava Rigidbody-komponentti. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Jokaisessa methodissa annetaan my&ouml;s Collision muuttuja, jonka voimme nimet&auml; miksi ikin&auml; haluammekaan, mutta itse nime&auml;n sen yleens&auml; &quot;col&quot; nimiseksi. T&auml;m&auml; Collision-muuttuja sis&auml;lt&auml;&auml; kaiken informaation t&ouml;rm&auml;yksest&auml;, joka tapahtui. T&auml;st&auml; saamme esim. toisen objektin, johon t&auml;m&auml; objekti jossa koodimme on t&ouml;rm&auml;si. Saamme t&auml;m&auml;n helposti kirjoittamalla col.gameObject, tai korvaamalla col miksi ikin&auml; nimesimmek&auml;&auml;n Collision-muuttujan.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mutta nyt, luodaan yksinkertaisesti koodi joka t&ouml;rm&auml;yksen tapahtuessa nollaa hypyt-muuttujan. Me lis&auml;simme jo OnCollisionStay methodin, joka siis suoritetaan aina kun pelaaja-objektimme osuu maahan. Methodin sis&auml;&auml;n asetetaan vain hypyt=0; joka nollaa hypyt. Nyt koko koodimme n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><a id="t.78dd1c0e8af5ccd3f339a668a01433c5acd0289f"></a><a id="t.10"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">using System.Collections;</span></p><p class="c1"><span class="c0">using System.Collections.Generic;</span></p><p class="c1"><span class="c0">using UnityEngine;</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">public class liikkuminen : MonoBehaviour</span></p><p class="c1"><span class="c0">{</span></p><p class="c1 c11"><span class="c0">int hypyt = 0;</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1 c11"><span class="c0">void Start ()</span></p><p class="c1 c11"><span class="c0">{</span></p><p class="c1 c5"><span class="c0">Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c1 c11"><span class="c0">}</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1 c11"><span class="c0">void Update ()</span></p><p class="c1 c11"><span class="c0">{</span></p><p class="c1 c5"><span class="c0">if (Input.GetAxis(&quot;Horizontal&quot;) != 0)</span></p><p class="c1 c5"><span class="c0">{</span></p><p class="c1 c8"><span class="c0">transform.position += transform.right * Input.GetAxis(&quot;Horizontal&quot;) / 4;</span></p><p class="c1 c5"><span class="c0">}</span></p><p class="c1 c5"><span class="c0">if (Input.GetAxis(&quot;Vertical&quot;) != 0)</span></p><p class="c1 c5"><span class="c0">{</span></p><p class="c1 c8"><span class="c0">transform.position += transform.forward * Input.GetAxis(&quot;Vertical&quot;) / 4;</span></p><p class="c1 c5"><span class="c0">}</span></p><p class="c1 c5"><span class="c0">if (Input.GetAxis(&quot;Mouse Y&quot;) != 0)</span></p><p class="c1 c5"><span class="c0">{</span></p><p class="c1 c8"><span class="c0">Camera.main.transform.eulerAngles -= Vector3.right * Input.GetAxis(&quot;Mouse Y&quot;);</span></p><p class="c1 c5"><span class="c0">}</span></p><p class="c1 c5"><span class="c0">if (Input.GetAxis(&quot;Mouse X&quot;) != 0)</span></p><p class="c1 c5"><span class="c0">{</span></p><p class="c1 c8"><span class="c0">transform.eulerAngles += Vector3.up * Input.GetAxis(&quot;Mouse X&quot;);</span></p><p class="c1 c5"><span class="c0">}</span></p><p class="c1 c5"><span class="c0">if (Input.GetMouseButtonDown(0))</span></p><p class="c1 c5"><span class="c0">{</span></p><p class="c1 c8"><span class="c0">Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c1 c5"><span class="c0">}</span></p><p class="c1 c5"><span class="c0">if (Input.GetButtonDown(&quot;Jump&quot;)&amp;&amp; hypyt!=2)</span></p><p class="c1 c5"><span class="c0">{</span></p><p class="c1 c8"><span class="c0">GetComponent&lt;Rigidbody&gt;().velocity = Vector3.up * 5;</span></p><p class="c1 c8"><span class="c0">hypyt++;</span></p><p class="c1 c5"><span class="c0">}</span></p><p class="c1 c11"><span class="c0">}</span></p><p class="c1 c11"><span class="c0">private void OnCollisionStay(Collision col)</span></p><p class="c1 c11"><span class="c0">{</span></p><p class="c1 c5"><span class="c0">hypyt = 0;</span></p><p class="c1 c11"><span class="c0">}</span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><h2 class="c16" id="h.idassofunv2c"><span class="c20">Kentt&auml;</span></h2><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">3D-mallit Unityyn</span></p><p class="c1"><span class="c3">Nyt olemme luoneet hyvin yksinkertaisen tasohyppelyn ohjaukset, Mutta pelikentt&auml;mme saattaa vaikuttaa hieman tyhj&auml;lt&auml;, joten lis&auml;t&auml;&auml;n blenderiss&auml; tekem&auml;mme kentt&auml; peliin. Mik&auml;li et ole viel&auml; tehnyt kentt&auml;&auml;, niin mene 3D-mallinnus materiaaleihin mist&auml; l&ouml;ytyy ohjeet t&auml;h&auml;n.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Avaa project n&auml;kym&auml;, ja klikkaa oikealla hiirell&auml; sielt&auml;, valitse ylin eli &quot;Create&quot;, ja taas ylin eli &quot;Folder&quot; niin luomme uuden kansion mihin laitamme 3D mallimme. Nime&auml; kansio siten ett&auml; tied&auml;t mit&auml; se sis&auml;lt&auml;&auml;, kuten &quot;3D-mallit&quot;. Avaa kansio tuplaklikkaamalla siit&auml;. Kun kansio on auki, avaa kansio miss&auml; sinulla on 3D-mallit, ja ved&auml; ne kansiosta Project-n&auml;kym&auml;n p&auml;&auml;lle. Unitylla saattaa kest&auml;&auml; hetki siirt&auml;&auml; 3D-mallit, mutta kun se on valmis, n&auml;kyv&auml;t kaikki tekem&auml;si 3D-mallit project-n&auml;kym&auml;ss&auml;. Jos olet luonut 3D-malleille materiaalit blenderiss&auml;, niin unity luo oman kansion mihin se on lis&auml;nnyt kaikki k&auml;ytt&auml;m&auml;si materiaalit.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">MeshCollider</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 240.30px; height: 386.39px;"><img alt="" src="unity1/images/image11.png" style="width: 240.30px; height: 386.39px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">&nbsp;Kun 3D-mallintamamme kentt&auml; n&auml;kyy project-n&auml;kym&auml;ss&auml;, otamme siit&auml; kiinni, ja ved&auml;mme sen Sceneen, jolloin koko 3D-mallinnus lis&auml;t&auml;&auml;n Sceneen. Varmistetaan ett&auml; mallin position on (0,0,0). Jos katsomme Hierarchy-n&auml;kym&auml;&auml;n, n&auml;emme ett&auml; 3D-mallimme nimi on siell&auml;, ja ett&auml; sill&auml; saattaa olla nuoli nimen vieress&auml;. Jos painamme nuolesta, avaa se meille v&auml;lilehden jossa n&auml;kyy kaikki 3D-mallinnuksessa olevat objektit. Valitaan n&auml;m&auml; kaikki, ja lis&auml;t&auml;&auml;n niihin MeshCollider. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">MeshCollider toimii samoin kuin kaikki muutkin Colliderit ja saa objektin t&ouml;rm&auml;&auml;m&auml;&auml;n muihin objekteihin. Erona muihin Collidereihin on se, ett&auml; MeshCollider saa muotonsa objektilta jossa se on, eli jos meill&auml; on 3D-mallinnettuna jokin hahmo tai muoto, saamme sille t&auml;ysin samanmuotoisen colliderin t&auml;ll&auml;. Jos 3D-objektimme on kuitenkin eritt&auml;in monimutkainen, saattaa t&auml;m&auml; olla pelilke raskas toteuttaa, mink&auml; takia yleens&auml; kannattaa turvautua tavallisiin collaidereihin.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">MeshCollider ei toimi t&auml;ll&auml;isen&auml;&auml;n Rigidbodyn kanssa, vaan t&auml;ll&ouml;in pit&auml;&auml; painaa Convex p&auml;&auml;lle. Nyt meid&auml;n ei t&auml;t&auml; tarvitse tehd&auml; koska emme ole rigidbodya objekteihin lis&auml;&auml;m&auml;ss&auml;. Convex luo objektin ymp&auml;rille yksinkertaisemman kehikon, joka my&ouml;s ottaa pois kaikki ontot kohdat. Esimerkiksi jos meill&auml; on kuppi, ja laitamme siihen MeshColliderin, toimii se niinkuin kuppi. Mutta jos painamme Convex-kohdan p&auml;&auml;lle. tulee siihen ik&auml;&auml;n kuin kansi p&auml;&auml;lle.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 457.90px; height: 157.50px;"><img alt="" src="unity1/images/image7.png" style="width: 457.90px; height: 157.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Muuta meid&auml;n ei tarvitse 3D-malleille tehd&auml;, ellemme halua muokkailla niit&auml; Unityssa. Emme voi muuttaa suoraa objektien muotoja, mutta jos blender-projektissamme oli useita eri objekteja, voimme siirrell&auml; ja monistaa niit&auml; haluamamme mukaan. T&auml;m&auml; onnistuu painamalla haluamaamme objektia oikealla hiirell&auml; ja valitsemalla duplicate, joka monistaa objektin, tai sitten copy pastella. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Koska lis&auml;simme kaikkiin objekteihin Mesh Colliderin, nyt jos testaamme peli&auml;, pystymme kulkemaan kent&auml;ss&auml;, mutta jos olemme t&ouml;rm&auml;&auml;m&auml;ss&auml; objektiin, menemmekin siit&auml; l&auml;pi, ellemme pys&auml;hdy. T&auml;m&auml; korjataan koodin puolella. Koodimme n&auml;ytt&auml;&auml; siis t&auml;lt&auml;</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.ba9867bbb6d50e6b890e9d047786e14deb4f35b1"></a><a id="t.11"></a><table class="c15"><tbody><tr class="c2"><td class="c13 c17" colspan="1" rowspan="1"><p class="c1"><span class="c0">using System.Collections;</span></p><p class="c1"><span class="c0">using System.Collections.Generic;</span></p><p class="c1"><span class="c0">using UnityEngine;</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">public class liikkuminen : MonoBehaviour {</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; // Use this for initialization</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; int hypyt = 0;</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Start () {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update is called once per frame</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Update () {</span></p><p class="c1"><span class="c22">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">if (Input.GetAxis(&quot;Horizontal&quot;) != 0)</span></p><p class="c1"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.position += transform.right * Input.GetAxis(&quot;Horizontal&quot;) / 4;</span></p><p class="c1"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Vertical&quot;) != 0)</span></p><p class="c1"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.position += transform.forward * Input.GetAxis(&quot;Vertical&quot;) / 4;</span></p><p class="c1"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Mouse Y&quot;) != 0)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Camera.main.transform.eulerAngles -= Vector3.right * Input.GetAxis(&quot;Mouse Y&quot;);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Mouse X&quot;) != 0)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.eulerAngles += Vector3.up * Input.GetAxis(&quot;Mouse X&quot;);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetMouseButtonDown(0))</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetButtonDown(&quot;Jump&quot;)&amp;&amp; hypyt!=2)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetComponent&lt;Rigidbody&gt;().velocity = Vector3.up * 5;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hypyt++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private void OnCollisionStay(Collision col)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; hypyt = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c22">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Lis&auml;sin osalle koodia taustan. T&auml;m&auml; koodin osa liikuttaa pelaaja-hahmoamme. Meid&auml;n on siirrett&auml;v&auml; se hieman toiseen paikkaan. Lis&auml;t&auml;&auml;n koodiin siis uusi methodi, void FixedUpdate(){}, ja lis&auml;t&auml;&auml;n v&auml;rj&auml;tty koodi sen sis&auml;&auml;n, jolloin koodi n&auml;ytt&auml;&auml; t&auml;lt&auml;: </span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.9df2b5e678e523480ff55535ba197588b2293dfa"></a><a id="t.12"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">using System.Collections;</span></p><p class="c1"><span class="c0">using System.Collections.Generic;</span></p><p class="c1"><span class="c0">using UnityEngine;</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">public class liikkuminen : MonoBehaviour {</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; // Use this for initialization</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; int hypyt = 0;</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Start () {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Update is called once per frame</span></p><p class="c1"><span class="c22">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Update () {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Mouse Y&quot;) != 0)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Camera.main.transform.eulerAngles -= Vector3.right * Input.GetAxis(&quot;Mouse Y&quot;);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Mouse X&quot;) != 0)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.eulerAngles += Vector3.up * Input.GetAxis(&quot;Mouse X&quot;);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetMouseButtonDown(0))</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetButtonDown(&quot;Jump&quot;)&amp;&amp; hypyt!=2)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetComponent&lt;Rigidbody&gt;().velocity = Vector3.up * 5;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hypyt++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private void OnCollisionStay(Collision col)</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; hypyt = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">void FixedUpdate()</span></p><p class="c1"><span class="c22">&nbsp; &nbsp; </span><span class="c0 c14">{</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Horizontal&quot;) != 0)</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.position += transform.right * Input.GetAxis(&quot;Horizontal&quot;) / 4;</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Vertical&quot;) != 0)</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.position += transform.forward * Input.GetAxis(&quot;Vertical&quot;) / 4;</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0 c14">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c22">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Ainut ero koodiimme on, ett&auml; loimme FixedUpdate methodin ja lis&auml;simme liikkumisen siihen. Nyt hahmomme ei en&auml;&auml; mene objektien l&auml;pi.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">FixedUpdate</span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span class="c3">FixedUpdate on Update-methodin kaltainen, joka toistuu koko ajan pelin aikana. Toisin kuin Update-methodi joka toistuu joka framella, FixedUpdate toistuu fysiikan kanssa samaan aikaan. T&auml;m&auml; mahdollistaa sen, ett&auml; nyt fysiikat pystyv&auml;t est&auml;m&auml;&auml;n esineiden l&auml;pi menemisen kun liikutamme pelaaja-hahmoa. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt pystymme hyppim&auml;&auml;n peliss&auml; eteenp&auml;in, ja katsomaan kaikkialle. Valitettavasti, nyt meid&auml;n on my&ouml;s mahdollista hyp&auml;t&auml; kent&auml;st&auml; ulos, sek&auml; mahdollisesti rotkoon p&auml;&auml;sem&auml;tt&auml; ulos. T&auml;m&auml; on korjattava.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">tRajat</span></p><p class="c1"><span class="c3">Sein&auml;t meid&auml;n on helppo kent&auml;lle tehd&auml;. Luodaan 4 (tai enemm&auml;n jos tarvitsee) objektia peliin, ja asetetaan kaikille BoxColliderit. Skaalataan objekteja niin paljon ett&auml; saamme tarpeeksi suuret sein&auml;t peitt&auml;m&auml;&auml;n kaikki ulosp&auml;&auml;syt kent&auml;n reunoilta.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Samalla tavalla luomme kent&auml;lle my&ouml;s pohjan. Luo uusi objekti, aseta BoxCollider ja skaalaa se niin suureksi ett&auml; se peitt&auml;&auml; pohjan. Siirr&auml; sit&auml; niin ett&auml; saamme sen olemaan juuri ja juuri rotkon pohjan yl&auml;puolella kaikkialla. Voimme k&auml;ytt&auml;&auml; t&auml;h&auml;n my&ouml;s useampaa objektia jos haluamme. Lis&auml;t&auml;&auml;n kaikkii objekteihimme my&ouml;s tagi.</span></p><p class="c1"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span class="c9 c7">Tag</span></p><p class="c1"><span class="c3">Tagit on Unityn tapa tunnistaa ryhm&auml; objekteja, ja tehd&auml; niille mit&auml; haluamme. T&auml;t&auml; k&auml;ytet&auml;&auml;n l&auml;hinn&auml; koodissa tunnistamaan t&auml;m&auml;n ryhm&auml;n. Jokainen objekti on luotaessa &quot;Untagged&quot;. Kun painamme t&auml;st&auml;, n&auml;emme ryhm&auml;n Unityn omia tageja mit&auml; se k&auml;ytt&auml;&auml; hy&ouml;dykseen. Haluamme kuitenkin luoda ker&auml;tt&auml;ville objekteillemme aivan oman taginsa, joten valitse valikosta &quot;Add tag&quot;. T&auml;m&auml;n pit&auml;isi vaihtaa Inspector-n&auml;kym&auml;n aivan toisenlaiseksi. Nyt siin&auml; pit&auml;isi n&auml;ky&auml; lista, jossa vain lukee &quot;list is empty&quot;. Painetaan plussasta hieman t&auml;m&auml;n alapuolelta, ja nimet&auml;&auml;n tagimme, vaikka &quot;restart&quot;. Palaa takaisin pohjan collidereihin, ja avataan sama tag valikko kuin aikaisemmin, paitsi ett&auml; t&auml;ll&auml; kertaa aivan alimpana pit&auml;isi olla juuri lis&auml;&auml;m&auml;mme tag. Aseta t&auml;m&auml; objektimme tagiksi. Nyt pystymme koodissa tarkistamaan osummeko pohjaan, johon emme saisi osua.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Palataan aijemmin tekem&auml;&auml;mme koodiin. Luodaan aivan alkuun uusi Vector3 muuttuja, ja nimte&auml;&auml;n se vaikka &quot;alkukohta&quot; nimell&auml;. J&auml;tet&auml;&auml;n arvo kuitenkin tyhj&auml;ksi. Menn&auml;&auml;n Start methodiin, ja asetetaan siell&auml; juuri tekem&auml;mme muuttujan arvoksi &quot;transform.position&quot;. T&auml;m&auml;n j&auml;lkeen etsit&auml;&auml;n OnCollisionStay-kohta, ja luodaan sen sis&auml;lle uusi if-lause. Kirjoitetaan siihen:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.5f90eb8dd06976907003cf9087b39e2602a4113b"></a><a id="t.13"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c4"><span class="c0">if(col.gameObject.tag==&quot;restart&quot;){</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform.position=alkukohta;</span></p><p class="c4"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">T&auml;ll&auml; tavoin tarkistamme, onko t&ouml;rm&auml;&auml;m&auml;mme objektin tag restart. Jos se on, niin pelaaja-objektimme palaa aivan samaan kohtaan kuin se oli pelin alussakin, eli peli ik&auml;&auml;n kuin restarttaa. Tehd&auml;&auml;n if-lausekkeelle my&ouml;s else, johon laitamme OnCollisionStay-kohdassa jo olleen &quot;hyppy=0;&quot;. Nyt meill&auml; on rajat peliin asetettuna, ja voimme alkaa lis&auml;ilem&auml;&auml;n muitakin ominaisuuksiia.</span></p><h2 class="c16" id="h.jny8hbbb56fc"><span class="c20">Ker&auml;tt&auml;v&auml;t esineet</span></h2><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mik&auml;li haluamme, voimme lis&auml;t&auml; peliin ker&auml;tt&auml;vi&auml; esineit&auml;. Voimme luoda t&auml;ll&auml;isi&auml; esineit&auml; blenderiss&auml;, ja vain tuoda ne unityyn. Lis&auml;&auml; t&auml;ll&auml;inen ker&auml;tt&auml;v&auml; esine sceneen. Lis&auml;t&auml;&auml;n objektiin MeshCollider, ja painetaan ruksista, jossa lukee &quot;Convex&quot;. T&auml;m&auml; aukaisee muut komponentin valinnat meille. Painetaan ruksista jossa lukee &quot;IsTrigger&quot;, ja asetetaan se p&auml;&auml;lle. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Kuten olemme oppineet, ett&auml; objektit voivat t&ouml;rm&auml;t&auml; toisiinsa, on molemmissa oltava Collider-komponentti. Jotta voimme my&ouml;s tarkistaa koodissa t&ouml;rm&auml;&auml;mmek&ouml; objektiin, on molemmissa oltava Collider-komponentti. Jos haluamme, etteiv&auml;t objektit kuitenkaan vaikuta toisiinsa, mutta haluamme koodissa saada tiet&auml;&auml; mik&auml;li objektit t&ouml;rm&auml;&auml;v&auml;t, asetetaan t&auml;ll&ouml;in toinen objekteista Triggeriksi. Trigger siis tarkoittaa ett&auml; emme fyysisesti t&ouml;rm&auml;&auml; objektiin, vaan menemme siit&auml; suoraa l&auml;pi, mutta tunnistamme koodissa milloin t&auml;m&auml; tapahtuu.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Asetetaan ker&auml;tt&auml;v&auml;lle objektillemme my&ouml;s oma taginsa ja nimet&auml;&auml;n se vaikka &quot;collect&quot; nimell&auml;. Palataan takaisin koodiin, ja luodaan taas yksi Unityn omista methodeista, nimelt&auml; &quot;void OnTriggerEnter(Collider col){}&quot;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">OnTrigger</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">On Trigger-methodit toimivat aivan samalla tavoin kuin On Collision-methoditkin, eli on olemassa OnTriggerEnter, OnTriggerStay ja OnTriggerExit joiden toimintaperjaatteet on samat kuin OnCollisionissakin. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mit&auml; eroa on OnTrigger ja OnCollision methodeilla on juuri se, ett&auml; OnTrigger-methodissa toisen objektin Colliderin on oltava &quot;IsTrigger&quot;. My&ouml;s toinen ero methodeilla on, nimitt&auml;in OnCollision antaa aina muuttujan Collision, joka sis&auml;lt&auml;&auml; siis kaikki tiedot t&ouml;rm&auml;yksest&auml;. OnTrigger-methodit sen sijaan antavat Colliderin johon objektimme t&ouml;rm&auml;si. Collider-muuttujassa on vain Colliderin tiedot, Collision-muuttujassa saamma tarkan sijainnin miss&auml; t&ouml;rm&auml;ys tapahtui.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Lis&auml;simme ker&auml;tt&auml;v&auml;lle objektille tagin, joten tarkistetaan se samalla tavalla kuin aijemminkin. Jos tag on sama kuin haluamamme, niin kirjoitetaan methodin sis&auml;&auml;n koodi joka tuhoaa ker&auml;tt&auml;v&auml;n objektin. T&auml;m&auml; onnistuu kirjoittamalla:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.e620c3c11f20576ebd6b20800487375dee4a95b2"></a><a id="t.14"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">Destroy(col.gameObject);</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Eli nyt ohjelmamme uusi osa n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.eea973856b4654320ce03adbc3052cb168c097c1"></a><a id="t.15"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">void OnTriggerEnter(Collider col)</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(col.gameObject.tag==&quot;collect&quot;){</span></p><p class="c1"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy(col.gameObject);</span></p><p class="c1 c23"><span class="c0">}</span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt objektimme tuhoaa aina ker&auml;tt&auml;v&auml;n esineen kosketuksesta. Nyt esineet tosin n&auml;ytt&auml;v&auml;t tylsilt&auml; vain leijuessaan ilmassa liikkumatta. T&auml;m&auml;n voimme korjata tekem&auml;ll&auml; uuden scriptin. Eli luokaa uusi scripti &quot;scriptit&quot;-kansioon, ja nimetk&auml;&auml; se vaikka &quot;turn&quot; nimell&auml;. Lis&auml;t&auml;&auml;n t&auml;m&auml; scripti ker&auml;tt&auml;v&auml;&auml;n esineeseen, ja l&auml;hdet&auml;&auml;n sitten muokkaamaan sit&auml;. Eli kaksoiklikatkaa scripti auki.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Ker&auml;tt&auml;v&auml; esine script</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt meille aukeaa toinen scripti joka on yht&auml; tyhj&auml; kuin ensimm&auml;inenkin aluksi. T&auml;ll&auml; kertaa emme tarvitse Start-methodia, eli jos haluamme, voimme poistaa sen kokonaan scriptist&auml;. Luodaan sitten kaksi float-muuttujaa, ja nimet&auml;&auml;n ne vaikka nimill&auml; &quot;kohta&quot; ja &quot;suunta&quot;. Anna kohta-muuttujalle arvo 0, ja suunta-muuttujalle arvo 0.00sk-st5f.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Luodaan Update-methodin sis&auml;&auml;n if-lauseke, joka tarkistaa onko kohta-muuttujan arvo yht&auml;suuri tai suurempi kuin 0.025f. Jos on, annetaan suunta-muuttujan arvoksi -0.005f. </span></p><p class="c1"><span class="c3">Luodaan if-lausekkeelle else if, joka tarkistaa, onko kohta-muuttujan arvo yht&auml;suuri tai suurempi kuin -0.025f. Jos on, niin annetaan suunta-muuttujan arvoksi sittenkin 0.005f.</span></p><p class="c1"><span class="c3">T&auml;m&auml;n j&auml;lkeen plussataan kohta-muuttujaan suunta-muuttuja. Sitten transform.position asetetaan Vector3.up*kohta.</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.5dbf74b5eed1b84f22782bb1504049a8532b478a"></a><a id="t.16"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c4"><span class="c3">using System.Collections;</span></p><p class="c4"><span class="c3">using System.Collections.Generic;</span></p><p class="c4"><span class="c3">using UnityEngine;</span></p><p class="c4 c10"><span class="c3"></span></p><p class="c4"><span class="c3">public class turn : MonoBehaviour {</span></p><p class="c4 c10"><span class="c3"></span></p><p class="c4"><span class="c3">&nbsp; &nbsp; float kohta = 0;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; float suunta = 0.005f;</span></p><p class="c4 c10"><span class="c3"></span></p><p class="c4"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Update () {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; if (kohta &gt;= 0.025f)</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suunta = -0.001f;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; }else if (kohta &lt;= -0.025f)</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suunta = 0.001f;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; kohta += suunta;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; transform.position += Vector3.up*kohta;</span></p><p class="c4"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c4"><span class="c3">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mit&auml; koodimme nyt tekee, niin luomme aluksi kaksi muuttujaa, kohta-muuttujaan asetetaan kuinka paljon ker&auml;tt&auml;v&auml;n tavaran kohta muuttuu. suunta-muuttujaan asetetaan kuinka nopeasti ja mihin suuntaan tavara t&auml;ll&auml; hetkell&auml; liikkuu. If-lausekkeet tarkistavat onko kohta-muuttujan arvo muuttunut tarpeeksi, ett&auml; suuntaa voidaan vaihtaa p&auml;invastaiseen. T&auml;m&auml;n j&auml;lkeen lis&auml;t&auml;&auml;n kohta-muuttujaan suunta-muuttuja joka muuttaa sit&auml; tiettyyn suuntaan. Lopuksi t&auml;m&auml; muutos lis&auml;t&auml;&auml;n objektin t&auml;m&auml;nhetkiseen kohtaan.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mit&auml; koodimme tekee, on luo ker&auml;tt&auml;v&auml;lle esineelle pienen yl&ouml;s-alas liikkeen, mik&auml; tekee siit&auml; paljon mielenkiintoisemman n&auml;k&ouml;isen. Mik&auml;li haluamme ett&auml; objekti liikkuu ylemm&auml;s ja alemmas, muutetaan if-lausekkeiden sulkujen sis&auml;ll&auml; olevia lukuja suuremmaksi. Mik&auml;li haluamme nopeuttaa liikett&auml;, muutetaan if-lausekkeiden aaltosulkeiden sis&auml;ll&auml; olevia lukuja suuremmaksi. Samat toimivat p&auml;in vastoin jos haluamme hidastaa esinett&auml;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span>Lis&auml;t&auml;&auml;n viel&auml; Update-methodin loppuun &quot;</span><span class="c7">transform.eulerAngles += Vector3.up;</span><span class="c3">&quot; . T&auml;m&auml; lis&auml;&auml; objektille py&ouml;rimisen tietyn akselin ymp&auml;ri. Voit nopeuttaa t&auml;t&auml; py&ouml;rimist&auml; kertomalla Vector3.up jollakin, ja hidastaa py&ouml;rimist&auml; jakamalla sen. Voimme vaihtaa py&ouml;rimissuuntaa laittamalla &quot;+=&quot; sijaan &quot;-=&quot;, ja vaihtaa akselia vaihtamalla &quot;Vector3.right&quot; tilalle joko &quot;Vector3.up&quot; tai &quot;Vector3.forward&quot;.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt ker&auml;tt&auml;v&auml; asiamme on paljon houkuttelevamman n&auml;k&ouml;inen. Voitte itse mietti&auml; miten saisitte ohjelman laskemaan kuinka monta objektia se on ker&auml;nnyt. Voit monistaa ker&auml;tt&auml;vi&auml; objekteja niin monta kuin haluatte copy-pastettamalla objektia, tai oikealla hiirell&auml; klikkaamalla siit&auml; Hierarchy-n&auml;kym&auml;ss&auml;, ja painamalla duplicate.</span></p><h2 class="c16" id="h.jorjueuyss7t"><span class="c20">Parempi hyppy</span></h2><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Pelimme ohjaukset ovat hyv&auml;t, mutta ne eiv&auml;t silti ole t&auml;ydelliset. T&auml;ll&auml; hetkell&auml; pystymme nimitt&auml;in hyppim&auml;&auml;n seini&auml; suoraa yl&ouml;sp&auml;in jos yrit&auml;mme. Vaikka t&auml;m&auml;n voi ottaa ominaisuutena, niin min&auml; n&auml;en sen bugina mik&auml; pit&auml;&auml; korjata. T&auml;m&auml; onnistuu parantelemalla hieman koodiamme.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Etsit&auml;&auml;n OnCollisionStay-kohta, jossa meill&auml; on if-lauseke, ja t&auml;lle else-lauseke. Elsess&auml; meill&auml; on vain &quot;hypyt=0;&quot;, joka restarttaa hypp&auml;&auml;misemme, mik&auml;li vain osumme johkin objektiin. T&auml;m&auml; ei tarkista yht&auml;&auml;n miss&auml; osumamme objekti on. T&auml;m&auml; korjataan luomalla uusi if-lauseke joka n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.ea13cf8f4c15da894caf1ebb4e9eb5ef9782a862"></a><a id="t.17"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">if(Physics.Raycast(transform.position, Vector3.down, 2))</span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">hypyt=0;</span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c9 c7">Physics.Raycast</span></p><p class="c1 c10"><span class="c9 c7"></span></p><p class="c1"><span class="c3">Physics.Raycast on tapa tarkistaa onko antamamme pisteen l&auml;hell&auml; esineit&auml; tietyss&auml; suunnassa. Physics.RayCast:in sulkeiden sis&auml;&auml;n voimme laittaa monta eri muuttujaa, sill&auml; se voi toimia monella tavalla. </span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Mit&auml; me haluamme tehd&auml; on, annamme ensin alkupisteen, jos tarkistus l&auml;htee. Koska haluamme tarkistaa t&auml;m&auml;n pelaajaobjektin mukaan, laitamme siihen transform.position joka antaa meille pelaaja-objektin t&auml;m&auml;nhetkisen sijainnin. </span></p><p class="c1"><span class="c3">T&auml;m&auml;n j&auml;lkeen annamme suunnan josta haluamme tarkistaa onko siell&auml; objekteja. T&auml;m&auml; onnistuu antamalla sille Vector3.down, joka antaa juuri alasp&auml;in suuntaan menev&auml;n arvon. </span></p><p class="c1"><span class="c3">T&auml;m&auml;n j&auml;lkeen annamme numeron milt&auml; et&auml;isyydelt&auml; Physics.Raycast katsoo esinett&auml;. Asettamalla 2, tarkistamme suurin piirtein juuri objektin alapuolelta, onko esinett&auml; siin&auml;. Jos objektin alapuolella on esine, niin jatkamme if-lausekkeen aaltosulkeiden sis&auml;lle.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Aaltosulkeiden sis&auml;lle laitamme &quot;hypyt=0&quot;, ja poistamme sen aijemmasta kohtaa. Nyt, jos ohjelma tunnistaa ett&auml; pelaajan alla on maata, asettaa se hypyt nolllle, niin nyt pystymme hyppim&auml;&auml;n taas.</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt olemme luoneet tasohyppely pelin, jossa on ker&auml;tt&auml;vi&auml; asioita, sek&auml; loistavat ohjaukset. Jos teill&auml; on ehdottaa jotain mit&auml; peliin lis&auml;&auml;mme, niin kannattaa selvitt&auml;&auml; netist&auml; miten t&auml;m&auml;n voi tehd&auml;, tai kysy&auml; ohjaajiltamme apua</span></p><p class="c1 c10"><span class="c3"></span></p><h2 class="c16" id="h.z1kfuamypn0h"><span class="c20">Extra! Juoksu</span></h2><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Voimme luoda tasohyppelyyn viel&auml; juoksunapin jos haluamme. T&auml;m&auml; onnistuu luomalla ensin float muuttujan samaan kohtaan kuin hypyt. Sille voidaan antaa nimeksi vaikka &quot;juoksu&quot;. Asetetaan sen arvoksi 1. Sitten luodaan Update()-methodiin uusi if-lauseke ja sille else, joka menee n&auml;in:</span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.c609cb7e3430e20a935eeea5e3344634b36204ab"></a><a id="t.18"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">if(Input.GetButton(&quot;Fire3&quot;){</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">}else{</span></p><p class="c1 c10"><span class="c0"></span></p><p class="c1"><span class="c0">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Fire3 tarkoittaa vasenta shift-painiketta, sek&auml; ohjaimessa omaa painiketta. T&auml;st&auml; tulee meille juoksu nappi. Lis&auml;t&auml;&auml;n if-lausekkeen sis&auml;&auml;n ett&auml; juoksu onkin 1.5f. Laitetaan else-lausekkeen sis&auml;&auml;n ett&auml;&auml; juoksu onkin taas 1. Eli nyt koodi n&auml;ytt&auml;&auml; t&auml;lt&auml;:</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.28d27f5dc02578e7d8855a379d42e8abb7c7c15c"></a><a id="t.19"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c1"><span class="c0">if(Input.GetButton(&quot;Fire3&quot;){</span></p><p class="c1"><span class="c0">juoksu=1.5f;</span></p><p class="c1"><span class="c0">}else{</span></p><p class="c1"><span class="c0">juoksu=1;</span></p><p class="c1"><span class="c22">}</span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt siirryt&auml;&auml;n FixedUpdate()-methodiin, jossa liikutamme pelihahmoamme. 2 rivi&auml; jotka alkavat sanoilla transform.position, lis&auml;&auml; n&auml;iden rivien aivan loppuun ennen puolipilkkua *juoksu .</span></p><p class="c1 c10"><span class="c3"></span></p><p class="c1 c10"><span class="c3"></span></p><a id="t.7c57b73eed9fd0de246bb8fe1aa65495310aed69"></a><a id="t.20"></a><table class="c15"><tbody><tr class="c2"><td class="c13" colspan="1" rowspan="1"><p class="c4"><span>&nbsp; &nbsp; </span><span class="c3 c14">float juoksu = 1;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; int hypyt = 0;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; // Use this for initialization</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; void Start()</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; Cursor.lockState = CursorLockMode.Locked;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; }</span></p><p class="c4 c10"><span class="c3"></span></p><p class="c4"><span class="c3">&nbsp; &nbsp; // Update is called once per frame</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; void Update()</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Mouse Y&quot;) != 0)</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Camera.main.transform.eulerAngles -= Vector3.right * Input.GetAxis(&quot;Mouse Y&quot;);</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Mouse X&quot;) != 0)</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.eulerAngles += Vector3.up * Input.GetAxis(&quot;Mouse X&quot;);</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; hypyt != 2)</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetComponent&lt;Rigidbody&gt;().velocity = Vector3.up * 10;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hypyt++;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c14">&nbsp;if (Input.GetButton(&quot;Fire3&quot;))</span></p><p class="c4"><span class="c3 c14">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c3 c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; juoksu = 1.5f;</span></p><p class="c4"><span class="c3 c14">&nbsp; &nbsp; &nbsp; &nbsp; }else</span></p><p class="c4"><span class="c3 c14">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span class="c3 c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; juoksu = 1;</span></p><p class="c4"><span class="c3 c14">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; void FixedUpdate()</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; {</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Horizontal&quot;) != 0)</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.position += transform.right * Input.GetAxis(&quot;Horizontal&quot;) / 6 </span><span class="c14">* juoksu</span><span class="c3">;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetAxis(&quot;Vertical&quot;) != 0)</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c4"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform.position += transform.forward * Input.GetAxis(&quot;Vertical&quot;) / 6 </span><span class="c14">* juoksu</span><span class="c3">;</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c3">&nbsp; &nbsp; }</span></p><p class="c4 c10"><span class="c3"></span></p></td></tr></tbody></table><p class="c1 c10"><span class="c3"></span></p><p class="c1"><span class="c3">Nyt kun pelaamme peli&auml; ja painamme vasenta shift-n&auml;pp&auml;int&auml; liikkuessamme, kuljemme hieman kovempaa, ik&auml;&auml;n kuin juoksisimme.</span></p><div><p class="c1 c10"><span class="c3"></span></p></div>


<br><br><br>
<div class="logo-container">
  <div class="logo-image">
    <img src="logos/liiveri.jpg" />
  </div>
  <div class="logo-image">
    <img src="logos/eakr.jpg" />
  </div>
  <div class="logo-image">
    <img src="logos/leader.jpg" />
  </div>
  <p>T√§m√§ materiaali on tuotettu Euroopan maaseudun kehitt√§misen maatalousrahaston tuella</p>
</div>

</body></html>
